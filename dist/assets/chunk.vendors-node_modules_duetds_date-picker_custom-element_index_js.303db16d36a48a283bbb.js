"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunk_ember_auto_import_"] = globalThis["webpackChunk_ember_auto_import_"] || []).push([["vendors-node_modules_duetds_date-picker_custom-element_index_js"],{

/***/ "./node_modules/@duetds/date-picker/custom-element/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@duetds/date-picker/custom-element/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DuetDatePicker\": () => (/* binding */ DuetDatePicker$1),\n/* harmony export */   \"defineCustomElements\": () => (/* binding */ defineCustomElements),\n/* harmony export */   \"setAssetPath\": () => (/* reexport safe */ _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.setAssetPath),\n/* harmony export */   \"setPlatformOptions\": () => (/* reexport safe */ _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.setPlatformOptions)\n/* harmony export */ });\n/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client */ \"./node_modules/@stencil/core/internal/client/index.js\");\nconst ISO_DATE_FORMAT=/^(\\d{4})-(\\d{2})-(\\d{2})$/;var DaysOfWeek;(function(DaysOfWeek){DaysOfWeek[DaysOfWeek[\"Sunday\"]=0]=\"Sunday\";DaysOfWeek[DaysOfWeek[\"Monday\"]=1]=\"Monday\";DaysOfWeek[DaysOfWeek[\"Tuesday\"]=2]=\"Tuesday\";DaysOfWeek[DaysOfWeek[\"Wednesday\"]=3]=\"Wednesday\";DaysOfWeek[DaysOfWeek[\"Thursday\"]=4]=\"Thursday\";DaysOfWeek[DaysOfWeek[\"Friday\"]=5]=\"Friday\";DaysOfWeek[DaysOfWeek[\"Saturday\"]=6]=\"Saturday\";})(DaysOfWeek||(DaysOfWeek={}));function createDate(year,month,day){var dayInt=parseInt(day,10);var monthInt=parseInt(month,10);var yearInt=parseInt(year,10);const isValid=Number.isInteger(yearInt)&&// all parts should be integers\nNumber.isInteger(monthInt)&&Number.isInteger(dayInt)&&monthInt>0&&// month must be 1-12\nmonthInt<=12&&dayInt>0&&// day must be 1-31\ndayInt<=31&&yearInt>0;if(isValid){return new Date(yearInt,monthInt-1,dayInt);}}/**\n * @param value date string in ISO format YYYY-MM-DD\n */function parseISODate(value){if(!value){return;}const matches=value.match(ISO_DATE_FORMAT);if(matches){return createDate(matches[1],matches[2],matches[3]);}}/**\n * print date in format YYYY-MM-DD\n * @param date\n */function printISODate(date){if(!date){return\"\";}var d=date.getDate().toString(10);var m=(date.getMonth()+1).toString(10);var y=date.getFullYear().toString(10);// days are not zero-indexed, so pad if less than 10\nif(date.getDate()<10){d=`0${d}`;}// months *are* zero-indexed, pad if less than 9!\nif(date.getMonth()<9){m=`0${m}`;}return`${y}-${m}-${d}`;}/**\n * Compare if two dates are equal in terms of day, month, and year\n */function isEqual(a,b){if(a==null||b==null){return false;}return isEqualMonth(a,b)&&a.getDate()===b.getDate();}/**\n * Compare if two dates are in the same month of the same year.\n */function isEqualMonth(a,b){if(a==null||b==null){return false;}return a.getFullYear()===b.getFullYear()&&a.getMonth()===b.getMonth();}function addDays(date,days){var d=new Date(date);d.setDate(d.getDate()+days);return d;}function startOfWeek(date){let firstDayOfWeek=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DaysOfWeek.Monday;var d=new Date(date);var day=d.getDay();var diff=(day<firstDayOfWeek?7:0)+day-firstDayOfWeek;d.setDate(d.getDate()-diff);return d;}function endOfWeek(date){let firstDayOfWeek=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DaysOfWeek.Monday;var d=new Date(date);var day=d.getDay();var diff=(day<firstDayOfWeek?-7:0)+6-(day-firstDayOfWeek);d.setDate(d.getDate()+diff);return d;}function startOfMonth(date){return new Date(date.getFullYear(),date.getMonth(),1);}function endOfMonth(date){return new Date(date.getFullYear(),date.getMonth()+1,0);}function setMonth(date,month){const d=new Date(date);d.setMonth(month);return d;}function setYear(date,year){const d=new Date(date);d.setFullYear(year);return d;}/**\n * Check if date is within a min and max\n */function inRange(date,min,max){return clamp(date,min,max)===date;}/**\n * Ensures date is within range, returns min or max if out of bounds\n */function clamp(date,min,max){const time=date.getTime();if(min&&min instanceof Date&&time<min.getTime()){return min;}if(max&&max instanceof Date&&time>max.getTime()){return max;}return date;}/**\n * given start and end date, return an (inclusive) array of all dates in between\n * @param start\n * @param end\n */function getDaysInRange(start,end){const days=[];let current=start;while(!isEqual(current,end)){days.push(current);current=addDays(current,1);}days.push(current);return days;}/**\n * given a date, return an array of dates from a calendar perspective\n * @param date\n * @param firstDayOfWeek\n */function getViewOfMonth(date){let firstDayOfWeek=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DaysOfWeek.Monday;const start=startOfWeek(startOfMonth(date),firstDayOfWeek);const end=endOfWeek(endOfMonth(date),firstDayOfWeek);return getDaysInRange(start,end);}/**\n * Form random hash\n */function chr4(){return Math.random().toString(16).slice(-4);}/**\n * Create random identifier with a prefix\n * @param prefix\n */function createIdentifier(prefix){return`${prefix}-${chr4()}${chr4()}-${chr4()}-${chr4()}-${chr4()}-${chr4()}${chr4()}${chr4()}`;}const DatePickerInput=_ref=>{let{onClick,dateFormatter,localization,name,formattedValue,valueAsDate,value,identifier,disabled,required,role,buttonRef,inputRef,onInput,onBlur,onFocus}=_ref;return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__input-wrapper\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"input\",{class:\"duet-date__input\",value:formattedValue,placeholder:localization.placeholder,id:identifier,disabled:disabled,role:role,required:required?true:undefined,\"aria-autocomplete\":\"none\",onInput:onInput,onFocus:onFocus,onBlur:onBlur,autoComplete:\"off\",ref:inputRef}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"input\",{type:\"hidden\",name:name,value:value}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"button\",{class:\"duet-date__toggle\",onClick:onClick,disabled:disabled,ref:buttonRef,type:\"button\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{class:\"duet-date__toggle-icon\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{\"aria-hidden\":\"true\",height:\"24\",viewBox:\"0 0 21 21\",width:\"24\",xmlns:\"http://www.w3.org/2000/svg\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"g\",{fill:\"none\",\"fill-rule\":\"evenodd\",transform:\"translate(2 2)\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"m2.5.5h12c1.1045695 0 2 .8954305 2 2v12c0 1.1045695-.8954305 2-2 2h-12c-1.1045695 0-2-.8954305-2-2v-12c0-1.1045695.8954305-2 2-2z\",stroke:\"currentColor\",\"stroke-linecap\":\"round\",\"stroke-linejoin\":\"round\"}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"m.5 4.5h16\",stroke:\"currentColor\",\"stroke-linecap\":\"round\",\"stroke-linejoin\":\"round\"}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"g\",{fill:\"currentColor\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"circle\",{cx:\"8.5\",cy:\"8.5\",r:\"1\"}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"circle\",{cx:\"4.5\",cy:\"8.5\",r:\"1\"}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"circle\",{cx:\"12.5\",cy:\"8.5\",r:\"1\"}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"circle\",{cx:\"8.5\",cy:\"12.5\",r:\"1\"}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"circle\",{cx:\"4.5\",cy:\"12.5\",r:\"1\"}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"circle\",{cx:\"12.5\",cy:\"12.5\",r:\"1\"}))))),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{class:\"duet-date__vhidden\"},localization.buttonLabel,valueAsDate&&(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",null,\", \",localization.selectedDateMessage,\" \",dateFormatter.format(valueAsDate)))));};const DatePickerDay=_ref2=>{let{focusedDay,today,day,onDaySelect,onKeyboardNavigation,focusedDayRef,disabled,inRange,isSelected,dateFormatter}=_ref2;const isToday=isEqual(day,today);const isMonth=isEqualMonth(day,focusedDay);const isFocused=isEqual(day,focusedDay);const isOutsideRange=!inRange;function handleClick(e){onDaySelect(e,day);}return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"button\",{class:{\"duet-date__day\":true,\"is-outside\":isOutsideRange,\"is-today\":isToday,\"is-month\":isMonth,\"is-disabled\":disabled},tabIndex:isFocused?0:-1,onClick:handleClick,onKeyDown:onKeyboardNavigation,\"aria-disabled\":disabled?\"true\":undefined,disabled:isOutsideRange,type:\"button\",\"aria-pressed\":isSelected?\"true\":\"false\",ref:el=>{if(isFocused&&el&&focusedDayRef){focusedDayRef(el);}}},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{\"aria-hidden\":\"true\"},day.getDate()),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{class:\"duet-date__vhidden\"},dateFormatter.format(day)));};function chunk(array,chunkSize){const result=[];for(let i=0;i<array.length;i+=chunkSize){result.push(array.slice(i,i+chunkSize));}return result;}function mapWithOffset(array,startingOffset,mapFn){return array.map((_,i)=>{const adjustedIndex=(i+startingOffset)%array.length;return mapFn(array[adjustedIndex]);});}const DatePickerMonth=_ref3=>{let{selectedDate,focusedDate,labelledById,localization,firstDayOfWeek,min,max,dateFormatter,isDateDisabled,onDateSelect,onKeyboardNavigation,focusedDayRef}=_ref3;const today=new Date();const days=getViewOfMonth(focusedDate,firstDayOfWeek);return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"table\",{class:\"duet-date__table\",\"aria-labelledby\":labelledById},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"thead\",null,(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"tr\",null,mapWithOffset(localization.dayNames,firstDayOfWeek,dayName=>(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"th\",{class:\"duet-date__table-header\",scope:\"col\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{\"aria-hidden\":\"true\"},dayName.substr(0,2)),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{class:\"duet-date__vhidden\"},dayName))))),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"tbody\",null,chunk(days,7).map(week=>(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"tr\",{class:\"duet-date__row\"},week.map(day=>(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"td\",{class:\"duet-date__cell\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(DatePickerDay,{day:day,today:today,focusedDay:focusedDate,isSelected:isEqual(day,selectedDate),disabled:isDateDisabled(day),inRange:inRange(day,min,max),onDaySelect:onDateSelect,dateFormatter:dateFormatter,onKeyboardNavigation:onKeyboardNavigation,focusedDayRef:focusedDayRef})))))));};const localization={buttonLabel:\"Choose date\",placeholder:\"YYYY-MM-DD\",selectedDateMessage:\"Selected date is\",prevMonthLabel:\"Previous month\",nextMonthLabel:\"Next month\",monthSelectLabel:\"Month\",yearSelectLabel:\"Year\",closeLabel:\"Close window\",calendarHeading:\"Choose a date\",dayNames:[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],monthNames:[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],monthNamesShort:[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],locale:\"en-GB\"};const isoAdapter={parse:parseISODate,format:printISODate};const duetDatePickerCss=\".duet-date *,.duet-date *::before,.duet-date *::after{box-sizing:border-box;margin:0;width:auto}.duet-date{box-sizing:border-box;color:var(--duet-color-text);display:block;font-family:var(--duet-font);margin:0;position:relative;text-align:left;width:100%}.duet-date__input{-webkit-appearance:none;appearance:none;background:var(--duet-color-surface);border:1px solid var(--duet-color-border, var(--duet-color-text));border-radius:var(--duet-radius);color:var(--duet-color-text);float:none;font-family:var(--duet-font);font-size:100%;line-height:normal;padding:14px 60px 14px 14px;width:100%}.duet-date__input:focus{border-color:var(--duet-color-primary);box-shadow:0 0 0 1px var(--duet-color-primary);outline:0}.duet-date__input::-webkit-input-placeholder{color:var(--duet-color-placeholder);opacity:1}.duet-date__input:-moz-placeholder{color:var(--duet-color-placeholder);opacity:1}.duet-date__input:-ms-input-placeholder{color:var(--duet-color-placeholder)}.duet-date__input-wrapper{position:relative;width:100%}.duet-date__toggle{-moz-appearance:none;-webkit-appearance:none;-webkit-user-select:none;align-items:center;appearance:none;background:var(--duet-color-button);border:0;border-radius:0;border-bottom-right-radius:var(--duet-radius);border-top-right-radius:var(--duet-radius);box-shadow:inset 1px 0 0 rgba(0, 0, 0, 0.1);color:var(--duet-color-text);cursor:pointer;display:flex;height:calc(100% - 2px);justify-content:center;padding:0;position:absolute;right:1px;top:1px;user-select:none;width:48px;z-index:2}.duet-date__toggle:focus{box-shadow:0 0 0 2px var(--duet-color-primary);outline:0}.duet-date__toggle-icon{display:flex;flex-basis:100%;justify-content:center;align-items:center}.duet-date__dialog{display:flex;left:0;min-width:320px;opacity:0;position:absolute;top:100%;transform:scale(0.96) translateZ(0) translateY(-20px);transform-origin:top right;transition:transform 300ms ease, opacity 300ms ease, visibility 300ms ease;visibility:hidden;width:100%;will-change:transform, opacity, visibility;z-index:var(--duet-z-index)}@media (max-width: 35.9375em){.duet-date__dialog{background:var(--duet-color-overlay);bottom:0;position:fixed;right:0;top:0;transform:translateZ(0);transform-origin:bottom center}}.duet-date__dialog.is-left{left:auto;right:0;width:auto}.duet-date__dialog.is-active{opacity:1;transform:scale(1.0001) translateZ(0) translateY(0);visibility:visible}.duet-date__dialog-content{background:var(--duet-color-surface);border:1px solid rgba(0, 0, 0, 0.1);border-radius:var(--duet-radius);box-shadow:0 4px 10px 0 rgba(0, 0, 0, 0.1);margin-left:auto;margin-top:8px;max-width:310px;min-width:290px;padding:16px 16px 20px;position:relative;transform:none;width:100%;z-index:var(--duet-z-index)}@media (max-width: 35.9375em){.duet-date__dialog-content{border:0;border-radius:0;border-top-left-radius:var(--duet-radius);border-top-right-radius:var(--duet-radius);bottom:0;left:0;margin:0;max-width:none;min-height:26em;opacity:0;padding:0 8% 20px;position:absolute;transform:translateZ(0) translateY(100%);transition:transform 400ms ease, opacity 400ms ease, visibility 400ms ease;visibility:hidden;will-change:transform, opacity, visibility}.is-active .duet-date__dialog-content{opacity:1;transform:translateZ(0) translateY(0);visibility:visible}}.duet-date__table{border-collapse:collapse;border-spacing:0;color:var(--duet-color-text);font-size:1rem;font-weight:var(--duet-font-normal);line-height:1.25;text-align:center;width:100%}.duet-date__table-header{font-size:0.75rem;font-weight:var(--duet-font-bold);letter-spacing:1px;line-height:1.25;padding-bottom:8px;text-decoration:none;text-transform:uppercase}.duet-date__cell{text-align:center}.duet-date__day{-moz-appearance:none;-webkit-appearance:none;appearance:none;background:transparent;border:0;border-radius:50%;color:var(--duet-color-text);cursor:pointer;display:inline-block;font-family:var(--duet-font);font-size:0.875rem;font-variant-numeric:tabular-nums;font-weight:var(--duet-font-normal);height:36px;line-height:1.25;padding:0 0 1px;position:relative;text-align:center;vertical-align:middle;width:36px;z-index:1}.duet-date__day.is-today{box-shadow:0 0 0 1px var(--duet-color-primary);position:relative;z-index:200}.duet-date__day:hover::before,.duet-date__day.is-today::before{background:var(--duet-color-primary);border-radius:50%;bottom:0;content:\\\"\\\";left:0;opacity:0.06;position:absolute;right:0;top:0}.duet-date__day[aria-pressed=true],.duet-date__day:focus{background:var(--duet-color-primary);box-shadow:none;color:var(--duet-color-text-active);outline:0}.duet-date__day:active{background:var(--duet-color-primary);box-shadow:0 0 5px var(--duet-color-primary);color:var(--duet-color-text-active);z-index:200}.duet-date__day:focus{box-shadow:0 0 5px var(--duet-color-primary);z-index:200}.duet-date__day:not(.is-month){box-shadow:none}.duet-date__day:not(.is-month),.duet-date__day[aria-disabled=true]{background:transparent;color:var(--duet-color-text);cursor:default;opacity:0.5}.duet-date__day[aria-disabled=true].is-today{box-shadow:0 0 0 1px var(--duet-color-primary)}.duet-date__day[aria-disabled=true].is-today:focus{box-shadow:0 0 5px var(--duet-color-primary);background:var(--duet-color-primary);color:var(--duet-color-text-active)}.duet-date__day[aria-disabled=true]:not(.is-today)::before{display:none}.duet-date__day.is-outside{background:var(--duet-color-button);box-shadow:none;color:var(--duet-color-text);cursor:default;opacity:0.6;pointer-events:none}.duet-date__day.is-outside::before{display:none}.duet-date__header{align-items:center;display:flex;justify-content:space-between;margin-bottom:16px;width:100%}.duet-date__nav{white-space:nowrap}.duet-date__prev,.duet-date__next{-moz-appearance:none;-webkit-appearance:none;align-items:center;appearance:none;background:var(--duet-color-button);border:0;border-radius:50%;color:var(--duet-color-text);cursor:pointer;display:inline-flex;height:32px;justify-content:center;margin-left:8px;padding:0;transition:background-color 300ms ease;width:32px}@media (max-width: 35.9375em){.duet-date__prev,.duet-date__next{height:40px;width:40px}}.duet-date__prev:focus,.duet-date__next:focus{box-shadow:0 0 0 2px var(--duet-color-primary);outline:0}.duet-date__prev:active:focus,.duet-date__next:active:focus{box-shadow:none}.duet-date__prev:disabled,.duet-date__next:disabled{cursor:default;opacity:0.5}.duet-date__prev svg,.duet-date__next svg{margin:0 auto}.duet-date__select{display:inline-flex;margin-top:4px;position:relative}.duet-date__select span{margin-right:4px}.duet-date__select select{cursor:pointer;font-size:1rem;height:100%;left:0;opacity:0;position:absolute;top:0;width:100%;z-index:2}.duet-date__select select:focus+.duet-date__select-label{box-shadow:0 0 0 2px var(--duet-color-primary)}.duet-date__select-label{align-items:center;border-radius:var(--duet-radius);color:var(--duet-color-text);display:flex;font-size:1.25rem;font-weight:var(--duet-font-bold);line-height:1.25;padding:0 4px 0 8px;pointer-events:none;position:relative;width:100%;z-index:1}.duet-date__select-label svg{width:16px;height:16px}.duet-date__mobile{align-items:center;border-bottom:1px solid rgba(0, 0, 0, 0.12);display:flex;justify-content:space-between;margin-bottom:20px;margin-left:-10%;overflow:hidden;padding:12px 20px;position:relative;text-overflow:ellipsis;white-space:nowrap;width:120%}@media (min-width: 36em){.duet-date__mobile{border:0;margin:0;overflow:visible;padding:0;position:absolute;right:-8px;top:-8px;width:auto}}.duet-date__mobile-heading{display:inline-block;font-weight:var(--duet-font-bold);max-width:84%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}@media (min-width: 36em){.duet-date__mobile-heading{display:none}}.duet-date__close{-webkit-appearance:none;align-items:center;appearance:none;background:var(--duet-color-button);border:0;border-radius:50%;color:var(--duet-color-text);cursor:pointer;display:flex;height:24px;justify-content:center;padding:0;width:24px}@media (min-width: 36em){.duet-date__close{opacity:0}}.duet-date__close:focus{box-shadow:0 0 0 2px var(--duet-color-primary);outline:none}@media (min-width: 36em){.duet-date__close:focus{opacity:1}}.duet-date__close svg{margin:0 auto}.duet-date__vhidden{border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;overflow:hidden;padding:0;position:absolute;top:0;width:1px}\";function range(from,to){var result=[];for(var i=from;i<=to;i++){result.push(i);}return result;}const keyCode={TAB:9,ESC:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40};function cleanValue(input,regex){const value=input.value;const cursor=input.selectionStart;const beforeCursor=value.slice(0,cursor);const afterCursor=value.slice(cursor,value.length);const filteredBeforeCursor=beforeCursor.replace(regex,\"\");const filterAfterCursor=afterCursor.replace(regex,\"\");const newValue=filteredBeforeCursor+filterAfterCursor;const newCursor=filteredBeforeCursor.length;input.value=newValue;input.selectionStart=input.selectionEnd=newCursor;return newValue;}const DISALLOWED_CHARACTERS=/[^0-9\\.\\/\\-]+/g;const TRANSITION_MS=300;const DuetDatePicker=class extends HTMLElement{constructor(){super();this.__registerHost();this.duetChange=(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this,\"duetChange\",7);this.duetBlur=(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this,\"duetBlur\",7);this.duetFocus=(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this,\"duetFocus\",7);this.duetOpen=(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this,\"duetOpen\",7);this.duetClose=(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this,\"duetClose\",7);/**\n     * Own Properties\n     */this.monthSelectId=createIdentifier(\"DuetDateMonth\");this.yearSelectId=createIdentifier(\"DuetDateYear\");this.dialogLabelId=createIdentifier(\"DuetDateLabel\");this.initialTouchX=null;this.initialTouchY=null;/**\n     * State() variables\n     */this.activeFocus=false;this.focusedDay=new Date();this.open=false;/**\n     * Public Property API\n     */ /**\n     * Name of the date picker input.\n     */this.name=\"date\";/**\n     * Adds a unique identifier for the date picker input. Use this instead of html `id` attribute.\n     */this.identifier=\"\";/**\n     * Makes the date picker input component disabled. This prevents users from being able to\n     * interact with the input, and conveys its inactive state to assistive technologies.\n     */this.disabled=false;/**\n     * Forces the opening direction of the calendar modal to be always left or right.\n     * This setting can be useful when the input is smaller than the opening date picker\n     * would be as by default the picker always opens towards right.\n     */this.direction=\"right\";/**\n     * Should the input be marked as required?\n     */this.required=false;/**\n     * Date value. Must be in IS0-8601 format: YYYY-MM-DD.\n     */this.value=\"\";/**\n     * Minimum date allowed to be picked. Must be in IS0-8601 format: YYYY-MM-DD.\n     * This setting can be used alone or together with the max property.\n     */this.min=\"\";/**\n     * Maximum date allowed to be picked. Must be in IS0-8601 format: YYYY-MM-DD.\n     * This setting can be used alone or together with the min property.\n     */this.max=\"\";/**\n     * Which day is considered first day of the week? `0` for Sunday, `1` for Monday, etc.\n     * Default is Monday.\n     */this.firstDayOfWeek=DaysOfWeek.Monday;/**\n     * Button labels, day names, month names, etc, used for localization.\n     * Default is English.\n     */this.localization=localization;/**\n     * Date adapter, for custom parsing/formatting.\n     * Must be object with a `parse` function which accepts a `string` and returns a `Date`,\n     * and a `format` function which accepts a `Date` and returns a `string`.\n     * Default is IS0-8601 parsing and formatting.\n     */this.dateAdapter=isoAdapter;/**\n     * Controls which days are disabled and therefore disallowed.\n     * For example, this can be used to disallow selection of weekends.\n     */this.isDateDisabled=()=>false;/**\n     * Local methods.\n     */this.enableActiveFocus=()=>{this.activeFocus=true;};this.disableActiveFocus=()=>{this.activeFocus=false;};this.toggleOpen=e=>{e.preventDefault();this.open?this.hide(false):this.show();};this.handleEscKey=event=>{if(event.keyCode===keyCode.ESC){this.hide();}};this.handleBlur=event=>{event.stopPropagation();this.duetBlur.emit({component:\"duet-date-picker\"});};this.handleFocus=event=>{event.stopPropagation();this.duetFocus.emit({component:\"duet-date-picker\"});};this.handleTouchStart=event=>{const touch=event.changedTouches[0];this.initialTouchX=touch.pageX;this.initialTouchY=touch.pageY;};this.handleTouchMove=event=>{event.preventDefault();};this.handleTouchEnd=event=>{const touch=event.changedTouches[0];const distX=touch.pageX-this.initialTouchX;// get horizontal dist traveled\nconst distY=touch.pageY-this.initialTouchY;// get vertical dist traveled\nconst threshold=70;const isHorizontalSwipe=Math.abs(distX)>=threshold&&Math.abs(distY)<=threshold;const isDownwardsSwipe=Math.abs(distY)>=threshold&&Math.abs(distX)<=threshold&&distY>0;if(isHorizontalSwipe){this.addMonths(distX<0?1:-1);}else if(isDownwardsSwipe){this.hide(false);event.preventDefault();}this.initialTouchY=null;this.initialTouchX=null;};this.handleNextMonthClick=event=>{event.preventDefault();this.addMonths(1);};this.handlePreviousMonthClick=event=>{event.preventDefault();this.addMonths(-1);};this.handleFirstFocusableKeydown=event=>{// this ensures focus is trapped inside the dialog\nif(event.keyCode===keyCode.TAB&&event.shiftKey){this.focusedDayNode.focus();event.preventDefault();}};this.handleKeyboardNavigation=event=>{// handle tab separately, since it needs to be treated\n// differently to other keyboard interactions\nif(event.keyCode===keyCode.TAB&&!event.shiftKey){event.preventDefault();this.firstFocusableElement.focus();return;}var handled=true;switch(event.keyCode){case keyCode.RIGHT:this.addDays(1);break;case keyCode.LEFT:this.addDays(-1);break;case keyCode.DOWN:this.addDays(7);break;case keyCode.UP:this.addDays(-7);break;case keyCode.PAGE_UP:if(event.shiftKey){this.addYears(-1);}else{this.addMonths(-1);}break;case keyCode.PAGE_DOWN:if(event.shiftKey){this.addYears(1);}else{this.addMonths(1);}break;case keyCode.HOME:this.startOfWeek();break;case keyCode.END:this.endOfWeek();break;default:handled=false;}if(handled){event.preventDefault();this.enableActiveFocus();}};this.handleDaySelect=(_event,day)=>{const isInRange=inRange(day,parseISODate(this.min),parseISODate(this.max));const isAllowed=!this.isDateDisabled(day);if(isInRange&&isAllowed){this.setValue(day);this.hide();}else{// for consistency we should set the focused day in cases where\n// user has selected a day that has been specifically disallowed\nthis.setFocusedDay(day);}};this.handleMonthSelect=e=>{this.setMonth(parseInt(e.target.value,10));};this.handleYearSelect=e=>{this.setYear(parseInt(e.target.value,10));};this.handleInputChange=()=>{const target=this.datePickerInput;// clean up any invalid characters\ncleanValue(target,DISALLOWED_CHARACTERS);const parsed=this.dateAdapter.parse(target.value,createDate);if(parsed||target.value===\"\"){this.setValue(parsed);}};this.processFocusedDayNode=element=>{this.focusedDayNode=element;if(this.activeFocus&&this.open){setTimeout(()=>element.focus(),0);}};}connectedCallback(){this.createDateFormatters();}createDateFormatters(){this.dateFormatShort=new Intl.DateTimeFormat(this.localization.locale,{day:\"numeric\",month:\"long\"});this.dateFormatLong=new Intl.DateTimeFormat(this.localization.locale,{day:\"numeric\",month:\"long\",year:\"numeric\"});}/**\n   * Component event handling.\n   */handleDocumentClick(e){if(!this.open){return;}// the dialog and the button aren't considered clicks outside.\n// dialog for obvious reasons, but the button needs to be skipped\n// so that two things are possible:\n//\n// a) clicking again on the button when dialog is open should close the modal.\n//    without skipping the button here, we would see a click outside\n//    _and_ a click on the button, so the `open` state goes\n//    open -> close (click outside) -> open (click button)\n//\n// b) clicking another date picker's button should close the current calendar\n//    and open the new one. this means we can't stopPropagation() on the button itself\n//\n// this was the only satisfactory combination of things to get the above to work\nconst isClickOutside=e.composedPath().every(node=>node!==this.dialogWrapperNode&&node!==this.datePickerButton);if(isClickOutside){this.hide(false);}}/**\n   * Public methods API\n   */ /**\n   * Sets focus on the date picker's input. Use this method instead of the global `focus()`.\n   */async setFocus(){return this.datePickerInput.focus();}/**\n   * Show the calendar modal, moving focus to the calendar inside.\n   */async show(){this.open=true;this.duetOpen.emit({component:\"duet-date-picker\"});this.setFocusedDay(parseISODate(this.value)||new Date());clearTimeout(this.focusTimeoutId);this.focusTimeoutId=setTimeout(()=>this.monthSelectNode.focus(),TRANSITION_MS);}/**\n   * Hide the calendar modal. Set `moveFocusToButton` to false to prevent focus\n   * returning to the date picker's button. Default is true.\n   */async hide(){let moveFocusToButton=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.open=false;this.duetClose.emit({component:\"duet-date-picker\"});// in cases where calendar is quickly shown and hidden\n// we should avoid moving focus to the button\nclearTimeout(this.focusTimeoutId);if(moveFocusToButton){// iOS VoiceOver needs to wait for all transitions to finish.\nsetTimeout(()=>this.datePickerButton.focus(),TRANSITION_MS+200);}}addDays(days){this.setFocusedDay(addDays(this.focusedDay,days));}addMonths(months){this.setMonth(this.focusedDay.getMonth()+months);}addYears(years){this.setYear(this.focusedDay.getFullYear()+years);}startOfWeek(){this.setFocusedDay(startOfWeek(this.focusedDay,this.firstDayOfWeek));}endOfWeek(){this.setFocusedDay(endOfWeek(this.focusedDay,this.firstDayOfWeek));}setMonth(month){const min=setMonth(startOfMonth(this.focusedDay),month);const max=endOfMonth(min);const date=setMonth(this.focusedDay,month);this.setFocusedDay(clamp(date,min,max));}setYear(year){const min=setYear(startOfMonth(this.focusedDay),year);const max=endOfMonth(min);const date=setYear(this.focusedDay,year);this.setFocusedDay(clamp(date,min,max));}setFocusedDay(day){this.focusedDay=clamp(day,parseISODate(this.min),parseISODate(this.max));}setValue(date){this.value=printISODate(date);this.duetChange.emit({component:\"duet-date-picker\",value:this.value,valueAsDate:date});}/**\n   * render() function\n   * Always the last one in the class.\n   */render(){const valueAsDate=parseISODate(this.value);const formattedDate=valueAsDate&&this.dateAdapter.format(valueAsDate);const selectedYear=(valueAsDate||this.focusedDay).getFullYear();const focusedMonth=this.focusedDay.getMonth();const focusedYear=this.focusedDay.getFullYear();const minDate=parseISODate(this.min);const maxDate=parseISODate(this.max);const prevMonthDisabled=minDate!=null&&minDate.getMonth()===focusedMonth&&minDate.getFullYear()===focusedYear;const nextMonthDisabled=maxDate!=null&&maxDate.getMonth()===focusedMonth&&maxDate.getFullYear()===focusedYear;const minYear=minDate?minDate.getFullYear():selectedYear-10;const maxYear=maxDate?maxDate.getFullYear():selectedYear+10;return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.Host,null,(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(DatePickerInput,{dateFormatter:this.dateFormatLong,value:this.value,valueAsDate:valueAsDate,formattedValue:formattedDate,onInput:this.handleInputChange,onBlur:this.handleBlur,onFocus:this.handleFocus,onClick:this.toggleOpen,name:this.name,disabled:this.disabled,role:this.role,required:this.required,identifier:this.identifier,localization:this.localization,buttonRef:element=>this.datePickerButton=element,inputRef:element=>this.datePickerInput=element}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:{\"duet-date__dialog\":true,\"is-left\":this.direction===\"left\",\"is-active\":this.open},role:\"dialog\",\"aria-modal\":\"true\",\"aria-hidden\":this.open?\"false\":\"true\",\"aria-labelledby\":this.dialogLabelId,onTouchMove:this.handleTouchMove,onTouchStart:this.handleTouchStart,onTouchEnd:this.handleTouchEnd},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__dialog-content\",onKeyDown:this.handleEscKey,ref:element=>this.dialogWrapperNode=element},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__mobile\",onFocusin:this.disableActiveFocus},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\",{class:\"duet-date__mobile-heading\"},this.localization.calendarHeading),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"button\",{class:\"duet-date__close\",ref:element=>this.firstFocusableElement=element,onKeyDown:this.handleFirstFocusableKeydown,onClick:()=>this.hide(),type:\"button\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{\"aria-hidden\":\"true\",fill:\"currentColor\",xmlns:\"http://www.w3.org/2000/svg\",width:\"16\",height:\"16\",viewBox:\"0 0 24 24\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M0 0h24v24H0V0z\",fill:\"none\"}),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M18.3 5.71c-.39-.39-1.02-.39-1.41 0L12 10.59 7.11 5.7c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41L10.59 12 5.7 16.89c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L12 13.41l4.89 4.89c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L13.41 12l4.89-4.89c.38-.38.38-1.02 0-1.4z\"})),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{class:\"duet-date__vhidden\"},this.localization.closeLabel))),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__header\",onFocusin:this.disableActiveFocus},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",null,(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"h2\",{id:this.dialogLabelId,class:\"duet-date__vhidden\",\"aria-live\":\"polite\",\"aria-atomic\":\"true\"},this.localization.monthNames[focusedMonth],\" \",this.focusedDay.getFullYear()),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\",{htmlFor:this.monthSelectId,class:\"duet-date__vhidden\"},this.localization.monthSelectLabel),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__select\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"select\",{id:this.monthSelectId,class:\"duet-date__select--month\",ref:element=>this.monthSelectNode=element,onChange:this.handleMonthSelect},this.localization.monthNames.map((month,i)=>(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"option\",{key:month,value:i,selected:i===focusedMonth,disabled:!inRange(new Date(focusedYear,i,1),minDate?startOfMonth(minDate):null,maxDate?endOfMonth(maxDate):null)},month))),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__select-label\",\"aria-hidden\":\"true\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",null,this.localization.monthNamesShort[focusedMonth]),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{fill:\"currentColor\",xmlns:\"http://www.w3.org/2000/svg\",width:\"16\",height:\"16\",viewBox:\"0 0 24 24\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M8.12 9.29L12 13.17l3.88-3.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-4.59 4.59c-.39.39-1.02.39-1.41 0L6.7 10.7c-.39-.39-.39-1.02 0-1.41.39-.38 1.03-.39 1.42 0z\"})))),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\",{htmlFor:this.yearSelectId,class:\"duet-date__vhidden\"},this.localization.yearSelectLabel),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__select\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"select\",{id:this.yearSelectId,class:\"duet-date__select--year\",onChange:this.handleYearSelect},range(minYear,maxYear).map(year=>(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"option\",{key:year,selected:year===focusedYear},year))),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__select-label\",\"aria-hidden\":\"true\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",null,this.focusedDay.getFullYear()),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{fill:\"currentColor\",xmlns:\"http://www.w3.org/2000/svg\",width:\"16\",height:\"16\",viewBox:\"0 0 24 24\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M8.12 9.29L12 13.17l3.88-3.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-4.59 4.59c-.39.39-1.02.39-1.41 0L6.7 10.7c-.39-.39-.39-1.02 0-1.41.39-.38 1.03-.39 1.42 0z\"}))))),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\",{class:\"duet-date__nav\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"button\",{class:\"duet-date__prev\",onClick:this.handlePreviousMonthClick,disabled:prevMonthDisabled,type:\"button\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{\"aria-hidden\":\"true\",fill:\"currentColor\",xmlns:\"http://www.w3.org/2000/svg\",width:\"21\",height:\"21\",viewBox:\"0 0 24 24\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M14.71 15.88L10.83 12l3.88-3.88c.39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0L8.71 11.3c-.39.39-.39 1.02 0 1.41l4.59 4.59c.39.39 1.02.39 1.41 0 .38-.39.39-1.03 0-1.42z\"})),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{class:\"duet-date__vhidden\"},this.localization.prevMonthLabel)),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"button\",{class:\"duet-date__next\",onClick:this.handleNextMonthClick,disabled:nextMonthDisabled,type:\"button\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{\"aria-hidden\":\"true\",fill:\"currentColor\",xmlns:\"http://www.w3.org/2000/svg\",width:\"21\",height:\"21\",viewBox:\"0 0 24 24\"},(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M9.29 15.88L13.17 12 9.29 8.12c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0l4.59 4.59c.39.39.39 1.02 0 1.41L10.7 17.3c-.39.39-1.02.39-1.41 0-.38-.39-.39-1.03 0-1.42z\"})),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\",{class:\"duet-date__vhidden\"},this.localization.nextMonthLabel)))),(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(DatePickerMonth,{dateFormatter:this.dateFormatShort,selectedDate:valueAsDate,focusedDate:this.focusedDay,onDateSelect:this.handleDaySelect,onKeyboardNavigation:this.handleKeyboardNavigation,labelledById:this.dialogLabelId,localization:this.localization,firstDayOfWeek:this.firstDayOfWeek,focusedDayRef:this.processFocusedDayNode,min:minDate,max:maxDate,isDateDisabled:this.isDateDisabled})))));}get element(){return this;}static get watchers(){return{\"localization\":[\"createDateFormatters\"]};}static get style(){return duetDatePickerCss;}};const DuetDatePicker$1=/*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.proxyCustomElement)(DuetDatePicker,[0,\"duet-date-picker\",{\"name\":[1],\"identifier\":[1],\"disabled\":[516],\"role\":[1],\"direction\":[1],\"required\":[4],\"value\":[1537],\"min\":[1],\"max\":[1],\"firstDayOfWeek\":[2,\"first-day-of-week\"],\"localization\":[16],\"dateAdapter\":[16],\"isDateDisabled\":[16],\"activeFocus\":[32],\"focusedDay\":[32],\"open\":[32]},[[6,\"click\",\"handleDocumentClick\"]]]);const defineCustomElements=opts=>{if(typeof customElements!=='undefined'){[DuetDatePicker$1].forEach(cmp=>{if(!customElements.get(cmp.is)){customElements.define(cmp.is,cmp,opts);}});}};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@duetds/date-picker/custom-element/index.js?");

/***/ }),

/***/ "./node_modules/@stencil/core/internal/client/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BUILD\": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD),\n/* harmony export */   \"Build\": () => (/* binding */ Build),\n/* harmony export */   \"CSS\": () => (/* binding */ CSS),\n/* harmony export */   \"Context\": () => (/* binding */ Context),\n/* harmony export */   \"Env\": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.Env),\n/* harmony export */   \"Fragment\": () => (/* binding */ Fragment),\n/* harmony export */   \"H\": () => (/* binding */ H),\n/* harmony export */   \"HTMLElement\": () => (/* binding */ H),\n/* harmony export */   \"Host\": () => (/* binding */ Host),\n/* harmony export */   \"NAMESPACE\": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE),\n/* harmony export */   \"STENCIL_DEV_MODE\": () => (/* binding */ STENCIL_DEV_MODE),\n/* harmony export */   \"addHostEventListeners\": () => (/* binding */ addHostEventListeners),\n/* harmony export */   \"bootstrapLazy\": () => (/* binding */ bootstrapLazy),\n/* harmony export */   \"cmpModules\": () => (/* binding */ cmpModules),\n/* harmony export */   \"connectedCallback\": () => (/* binding */ connectedCallback),\n/* harmony export */   \"consoleDevError\": () => (/* binding */ consoleDevError),\n/* harmony export */   \"consoleDevInfo\": () => (/* binding */ consoleDevInfo),\n/* harmony export */   \"consoleDevWarn\": () => (/* binding */ consoleDevWarn),\n/* harmony export */   \"consoleError\": () => (/* binding */ consoleError),\n/* harmony export */   \"createEvent\": () => (/* binding */ createEvent),\n/* harmony export */   \"defineCustomElement\": () => (/* binding */ defineCustomElement),\n/* harmony export */   \"disconnectedCallback\": () => (/* binding */ disconnectedCallback),\n/* harmony export */   \"doc\": () => (/* binding */ doc),\n/* harmony export */   \"forceModeUpdate\": () => (/* binding */ forceModeUpdate),\n/* harmony export */   \"forceUpdate\": () => (/* binding */ forceUpdate),\n/* harmony export */   \"getAssetPath\": () => (/* binding */ getAssetPath),\n/* harmony export */   \"getConnect\": () => (/* binding */ getConnect),\n/* harmony export */   \"getContext\": () => (/* binding */ getContext),\n/* harmony export */   \"getElement\": () => (/* binding */ getElement),\n/* harmony export */   \"getHostRef\": () => (/* binding */ getHostRef),\n/* harmony export */   \"getMode\": () => (/* binding */ getMode),\n/* harmony export */   \"getRenderingRef\": () => (/* binding */ getRenderingRef),\n/* harmony export */   \"getValue\": () => (/* binding */ getValue),\n/* harmony export */   \"h\": () => (/* binding */ h),\n/* harmony export */   \"insertVdomAnnotations\": () => (/* binding */ insertVdomAnnotations),\n/* harmony export */   \"isMemberInElement\": () => (/* binding */ isMemberInElement),\n/* harmony export */   \"loadModule\": () => (/* binding */ loadModule),\n/* harmony export */   \"modeResolutionChain\": () => (/* binding */ modeResolutionChain),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"parsePropertyValue\": () => (/* binding */ parsePropertyValue),\n/* harmony export */   \"plt\": () => (/* binding */ plt),\n/* harmony export */   \"postUpdateComponent\": () => (/* binding */ postUpdateComponent),\n/* harmony export */   \"promiseResolve\": () => (/* binding */ promiseResolve),\n/* harmony export */   \"proxyComponent\": () => (/* binding */ proxyComponent),\n/* harmony export */   \"proxyCustomElement\": () => (/* binding */ proxyCustomElement),\n/* harmony export */   \"readTask\": () => (/* binding */ readTask),\n/* harmony export */   \"registerHost\": () => (/* binding */ registerHost),\n/* harmony export */   \"registerInstance\": () => (/* binding */ registerInstance),\n/* harmony export */   \"renderVdom\": () => (/* binding */ renderVdom),\n/* harmony export */   \"setAssetPath\": () => (/* binding */ setAssetPath),\n/* harmony export */   \"setErrorHandler\": () => (/* binding */ setErrorHandler),\n/* harmony export */   \"setMode\": () => (/* binding */ setMode),\n/* harmony export */   \"setPlatformHelpers\": () => (/* binding */ setPlatformHelpers),\n/* harmony export */   \"setPlatformOptions\": () => (/* binding */ setPlatformOptions),\n/* harmony export */   \"setValue\": () => (/* binding */ setValue),\n/* harmony export */   \"styles\": () => (/* binding */ styles),\n/* harmony export */   \"supportsConstructableStylesheets\": () => (/* binding */ supportsConstructableStylesheets),\n/* harmony export */   \"supportsListenerOptions\": () => (/* binding */ supportsListenerOptions),\n/* harmony export */   \"supportsShadow\": () => (/* binding */ supportsShadow),\n/* harmony export */   \"win\": () => (/* binding */ win),\n/* harmony export */   \"writeTask\": () => (/* binding */ writeTask)\n/* harmony export */ });\n/* harmony import */ var _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/app-data */ \"./node_modules/@stencil/core/internal/app-data/index.js\");\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/snabbdom/snabbdom/blob/master/LICENSE\n *\n * Modified for Stencil's renderer and slot projection\n */let scopeId;let contentRef;let hostTagName;let customError;let i=0;let useNativeShadowDom=false;let checkSlotFallbackVisibility=false;let checkSlotRelocate=false;let isSvgMode=false;let renderingRef=null;let queueCongestion=0;let queuePending=false;/*\n Stencil Client Platform v2.18.1 | MIT Licensed | https://stenciljs.com\n */const Build={isDev:_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev?true:false,isBrowser:true,isServer:false,isTesting:_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting?true:false};const Context={};const getAssetPath=path=>{const assetUrl=new URL(path,plt.$resourcesUrl$);return assetUrl.origin!==win.location.origin?assetUrl.href:assetUrl.pathname;};const setAssetPath=path=>plt.$resourcesUrl$=path;const createTime=function(fnName){let tagName=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile&&performance.mark){const key=`st:${fnName}:${tagName}:${i++}`;// Start\nperformance.mark(key);// End\nreturn()=>performance.measure(`[Stencil] ${fnName}() <${tagName}>`,key);}else{return()=>{return;};}};const uniqueTime=(key,measureText)=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile&&performance.mark){if(performance.getEntriesByName(key).length===0){performance.mark(key);}return()=>{if(performance.getEntriesByName(measureText).length===0){performance.measure(measureText,key);}};}else{return()=>{return;};}};const inspect=ref=>{const hostRef=getHostRef(ref);if(!hostRef){return undefined;}const flags=hostRef.$flags$;const hostElement=hostRef.$hostElement$;return{renderCount:hostRef.$renderCount$,flags:{hasRendered:!!(flags&2/* HOST_FLAGS.hasRendered */),hasConnected:!!(flags&1/* HOST_FLAGS.hasConnected */),isWaitingForChildren:!!(flags&4/* HOST_FLAGS.isWaitingForChildren */),isConstructingInstance:!!(flags&8/* HOST_FLAGS.isConstructingInstance */),isQueuedForUpdate:!!(flags&16/* HOST_FLAGS.isQueuedForUpdate */),hasInitializedComponent:!!(flags&32/* HOST_FLAGS.hasInitializedComponent */),hasLoadedComponent:!!(flags&64/* HOST_FLAGS.hasLoadedComponent */),isWatchReady:!!(flags&128/* HOST_FLAGS.isWatchReady */),isListenReady:!!(flags&256/* HOST_FLAGS.isListenReady */),needsRerender:!!(flags&512/* HOST_FLAGS.needsRerender */)},instanceValues:hostRef.$instanceValues$,ancestorComponent:hostRef.$ancestorComponent$,hostElement,lazyInstance:hostRef.$lazyInstance$,vnode:hostRef.$vnode$,modeName:hostRef.$modeName$,onReadyPromise:hostRef.$onReadyPromise$,onReadyResolve:hostRef.$onReadyResolve$,onInstancePromise:hostRef.$onInstancePromise$,onInstanceResolve:hostRef.$onInstanceResolve$,onRenderResolve:hostRef.$onRenderResolve$,queuedListeners:hostRef.$queuedListeners$,rmListeners:hostRef.$rmListeners$,['s-id']:hostElement['s-id'],['s-cr']:hostElement['s-cr'],['s-lr']:hostElement['s-lr'],['s-p']:hostElement['s-p'],['s-rc']:hostElement['s-rc'],['s-sc']:hostElement['s-sc']};};const installDevTools=()=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.devTools){const stencil=win.stencil=win.stencil||{};const originalInspect=stencil.inspect;stencil.inspect=ref=>{let result=inspect(ref);if(!result&&typeof originalInspect==='function'){result=originalInspect(ref);}return result;};}};const CONTENT_REF_ID='r';const ORG_LOCATION_ID='o';const SLOT_NODE_ID='s';const TEXT_NODE_ID='t';const HYDRATE_ID='s-id';const HYDRATED_STYLE_ID='sty-id';const HYDRATE_CHILD_ID='c-id';const HYDRATED_CSS='{visibility:hidden}.hydrated{visibility:inherit}';const XLINK_NS='http://www.w3.org/1999/xlink';/**\n * Default style mode id\n */ /**\n * Reusable empty obj/array\n * Don't add values to these!!\n */const EMPTY_OBJ={};/**\n * Namespaces\n */const SVG_NS='http://www.w3.org/2000/svg';const HTML_NS='http://www.w3.org/1999/xhtml';const isDef=v=>v!=null;const isComplexType=o=>{// https://jsperf.com/typeof-fn-object/5\no=typeof o;return o==='object'||o==='function';};/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */ // const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h=function(nodeName,vnodeData){let child=null;let key=null;let slotName=null;let simple=false;let lastSimple=false;const vNodeChildren=[];const walk=c=>{for(let i=0;i<c.length;i++){child=c[i];if(Array.isArray(child)){walk(child);}else if(child!=null&&typeof child!=='boolean'){if(simple=typeof nodeName!=='function'&&!isComplexType(child)){child=String(child);}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev&&typeof nodeName!=='function'&&child.$flags$===undefined){consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);}if(simple&&lastSimple){// If the previous child was simple (string), we merge both\nvNodeChildren[vNodeChildren.length-1].$text$+=child;}else{// Append a new vNode, if it's text, we create a text vNode\nvNodeChildren.push(simple?newVNode(null,child):child);}lastSimple=simple;}}};for(var _len=arguments.length,children=new Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){children[_key-2]=arguments[_key];}walk(children);if(vnodeData){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev&&nodeName==='input'){validateInputProperties(vnodeData);}// normalize class / classname attributes\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey&&vnodeData.key){key=vnodeData.key;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&vnodeData.name){slotName=vnodeData.name;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass){const classData=vnodeData.className||vnodeData.class;if(classData){vnodeData.class=typeof classData!=='object'?classData:Object.keys(classData).filter(k=>classData[k]).join(' ');}}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev&&vNodeChildren.some(isHost)){consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomFunctional&&typeof nodeName==='function'){// nodeName is a functional component\nreturn nodeName(vnodeData===null?{}:vnodeData,vNodeChildren,vdomFnUtils);}const vnode=newVNode(nodeName,null);vnode.$attrs$=vnodeData;if(vNodeChildren.length>0){vnode.$children$=vNodeChildren;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey){vnode.$key$=key;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation){vnode.$name$=slotName;}return vnode;};const newVNode=(tag,text)=>{const vnode={$flags$:0,$tag$:tag,$text$:text,$elm$:null,$children$:null};if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute){vnode.$attrs$=null;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey){vnode.$key$=null;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation){vnode.$name$=null;}return vnode;};const Host={};const isHost=node=>node&&node.$tag$===Host;const vdomFnUtils={forEach:(children,cb)=>children.map(convertToPublic).forEach(cb),map:(children,cb)=>children.map(convertToPublic).map(cb).map(convertToPrivate)};const convertToPublic=node=>({vattrs:node.$attrs$,vchildren:node.$children$,vkey:node.$key$,vname:node.$name$,vtag:node.$tag$,vtext:node.$text$});const convertToPrivate=node=>{if(typeof node.vtag==='function'){const vnodeData=Object.assign({},node.vattrs);if(node.vkey){vnodeData.key=node.vkey;}if(node.vname){vnodeData.name=node.vname;}return h(node.vtag,vnodeData,...(node.vchildren||[]));}const vnode=newVNode(node.vtag,node.vtext);vnode.$attrs$=node.vattrs;vnode.$children$=node.vchildren;vnode.$key$=node.vkey;vnode.$name$=node.vname;return vnode;};/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */const validateInputProperties=inputElm=>{const props=Object.keys(inputElm);const value=props.indexOf('value');if(value===-1){return;}const typeIndex=props.indexOf('type');const minIndex=props.indexOf('min');const maxIndex=props.indexOf('max');const stepIndex=props.indexOf('step');if(value<typeIndex||value<minIndex||value<maxIndex||value<stepIndex){consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);}};const initializeClientHydrate=(hostElm,tagName,hostId,hostRef)=>{const endHydrate=createTime('hydrateClient',tagName);const shadowRoot=hostElm.shadowRoot;const childRenderNodes=[];const slotNodes=[];const shadowRootNodes=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&shadowRoot?[]:null;const vnode=hostRef.$vnode$=newVNode(tagName,null);if(!plt.$orgLocNodes$){initializeDocumentHydrate(doc.body,plt.$orgLocNodes$=new Map());}hostElm[HYDRATE_ID]=hostId;hostElm.removeAttribute(HYDRATE_ID);clientHydrate(vnode,childRenderNodes,slotNodes,shadowRootNodes,hostElm,hostElm,hostId);childRenderNodes.map(c=>{const orgLocationId=c.$hostId$+'.'+c.$nodeId$;const orgLocationNode=plt.$orgLocNodes$.get(orgLocationId);const node=c.$elm$;if(orgLocationNode&&supportsShadow&&orgLocationNode['s-en']===''){orgLocationNode.parentNode.insertBefore(node,orgLocationNode.nextSibling);}if(!shadowRoot){node['s-hn']=tagName;if(orgLocationNode){node['s-ol']=orgLocationNode;node['s-ol']['s-nr']=node;}}plt.$orgLocNodes$.delete(orgLocationId);});if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&shadowRoot){shadowRootNodes.map(shadowRootNode=>{if(shadowRootNode){shadowRoot.appendChild(shadowRootNode);}});}endHydrate();};const clientHydrate=(parentVNode,childRenderNodes,slotNodes,shadowRootNodes,hostElm,node,hostId)=>{let childNodeType;let childIdSplt;let childVNode;let i;if(node.nodeType===1/* NODE_TYPE.ElementNode */){childNodeType=node.getAttribute(HYDRATE_CHILD_ID);if(childNodeType){// got the node data from the element's attribute\n// `${hostId}.${nodeId}.${depth}.${index}`\nchildIdSplt=childNodeType.split('.');if(childIdSplt[0]===hostId||childIdSplt[0]==='0'){childVNode={$flags$:0,$hostId$:childIdSplt[0],$nodeId$:childIdSplt[1],$depth$:childIdSplt[2],$index$:childIdSplt[3],$tag$:node.tagName.toLowerCase(),$elm$:node,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null};childRenderNodes.push(childVNode);node.removeAttribute(HYDRATE_CHILD_ID);// this is a new child vnode\n// so ensure its parent vnode has the vchildren array\nif(!parentVNode.$children$){parentVNode.$children$=[];}// add our child vnode to a specific index of the vnode's children\nparentVNode.$children$[childVNode.$index$]=childVNode;// this is now the new parent vnode for all the next child checks\nparentVNode=childVNode;if(shadowRootNodes&&childVNode.$depth$==='0'){shadowRootNodes[childVNode.$index$]=childVNode.$elm$;}}}// recursively drill down, end to start so we can remove nodes\nfor(i=node.childNodes.length-1;i>=0;i--){clientHydrate(parentVNode,childRenderNodes,slotNodes,shadowRootNodes,hostElm,node.childNodes[i],hostId);}if(node.shadowRoot){// keep drilling down through the shadow root nodes\nfor(i=node.shadowRoot.childNodes.length-1;i>=0;i--){clientHydrate(parentVNode,childRenderNodes,slotNodes,shadowRootNodes,hostElm,node.shadowRoot.childNodes[i],hostId);}}}else if(node.nodeType===8/* NODE_TYPE.CommentNode */){// `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\nchildIdSplt=node.nodeValue.split('.');if(childIdSplt[1]===hostId||childIdSplt[1]==='0'){// comment node for either the host id or a 0 host id\nchildNodeType=childIdSplt[0];childVNode={$flags$:0,$hostId$:childIdSplt[1],$nodeId$:childIdSplt[2],$depth$:childIdSplt[3],$index$:childIdSplt[4],$elm$:node,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null};if(childNodeType===TEXT_NODE_ID){childVNode.$elm$=node.nextSibling;if(childVNode.$elm$&&childVNode.$elm$.nodeType===3/* NODE_TYPE.TextNode */){childVNode.$text$=childVNode.$elm$.textContent;childRenderNodes.push(childVNode);// remove the text comment since it's no longer needed\nnode.remove();if(!parentVNode.$children$){parentVNode.$children$=[];}parentVNode.$children$[childVNode.$index$]=childVNode;if(shadowRootNodes&&childVNode.$depth$==='0'){shadowRootNodes[childVNode.$index$]=childVNode.$elm$;}}}else if(childVNode.$hostId$===hostId){// this comment node is specifcally for this host id\nif(childNodeType===SLOT_NODE_ID){// `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\nchildVNode.$tag$='slot';if(childIdSplt[5]){node['s-sn']=childVNode.$name$=childIdSplt[5];}else{node['s-sn']='';}node['s-sr']=true;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&shadowRootNodes){// browser support shadowRoot and this is a shadow dom component\n// create an actual slot element\nchildVNode.$elm$=doc.createElement(childVNode.$tag$);if(childVNode.$name$){// add the slot name attribute\nchildVNode.$elm$.setAttribute('name',childVNode.$name$);}// insert the new slot element before the slot comment\nnode.parentNode.insertBefore(childVNode.$elm$,node);// remove the slot comment since it's not needed for shadow\nnode.remove();if(childVNode.$depth$==='0'){shadowRootNodes[childVNode.$index$]=childVNode.$elm$;}}slotNodes.push(childVNode);if(!parentVNode.$children$){parentVNode.$children$=[];}parentVNode.$children$[childVNode.$index$]=childVNode;}else if(childNodeType===CONTENT_REF_ID){// `${CONTENT_REF_ID}.${hostId}`;\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&shadowRootNodes){// remove the content ref comment since it's not needed for shadow\nnode.remove();}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation){hostElm['s-cr']=node;node['s-cn']=true;}}}}}else if(parentVNode&&parentVNode.$tag$==='style'){const vnode=newVNode(null,node.textContent);vnode.$elm$=node;vnode.$index$='0';parentVNode.$children$=[vnode];}};const initializeDocumentHydrate=(node,orgLocNodes)=>{if(node.nodeType===1/* NODE_TYPE.ElementNode */){let i=0;for(;i<node.childNodes.length;i++){initializeDocumentHydrate(node.childNodes[i],orgLocNodes);}if(node.shadowRoot){for(i=0;i<node.shadowRoot.childNodes.length;i++){initializeDocumentHydrate(node.shadowRoot.childNodes[i],orgLocNodes);}}}else if(node.nodeType===8/* NODE_TYPE.CommentNode */){const childIdSplt=node.nodeValue.split('.');if(childIdSplt[0]===ORG_LOCATION_ID){orgLocNodes.set(childIdSplt[1]+'.'+childIdSplt[2],node);node.nodeValue='';// useful to know if the original location is\n// the root light-dom of a shadow dom component\nnode['s-en']=childIdSplt[3];}}};// Private\nconst computeMode=elm=>modeResolutionChain.map(h=>h(elm)).find(m=>!!m);// Public\nconst setMode=handler=>modeResolutionChain.push(handler);const getMode=ref=>getHostRef(ref).$modeName$;/**\n * Parse a new property value for a given property type.\n *\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\n *   1. `any`, the type given to `propValue` in the function signature\n *   2. the type stored from `propType`.\n *\n * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.\n *\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\n * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\n * ```tsx\n * <my-cmp prop-val={0}></my-cmp>\n * ```\n *\n * HTML prop values on the other hand, will always a string\n *\n * @param propValue the new value to coerce to some type\n * @param propType the type of the prop, expressed as a binary number\n * @returns the parsed/coerced value\n */const parsePropertyValue=(propValue,propType)=>{// ensure this value is of the correct prop type\nif(propValue!=null&&!isComplexType(propValue)){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propBoolean&&propType&4/* MEMBER_FLAGS.Boolean */){// per the HTML spec, any string value means it is a boolean true value\n// but we'll cheat here and say that the string \"false\" is the boolean false\nreturn propValue==='false'?false:propValue===''||!!propValue;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propNumber&&propType&2/* MEMBER_FLAGS.Number */){// force it to be a number\nreturn parseFloat(propValue);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propString&&propType&1/* MEMBER_FLAGS.String */){// could have been passed as a number or boolean\n// but we still want it as a string\nreturn String(propValue);}// redundant return here for better minification\nreturn propValue;}// not sure exactly what type we want\n// so no need to change to a different type\nreturn propValue;};const getElement=ref=>_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad?getHostRef(ref).$hostElement$:ref;const createEvent=(ref,name,flags)=>{const elm=getElement(ref);return{emit:detail=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev&&!elm.isConnected){consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);}return emitEvent(elm,name,{bubbles:!!(flags&4/* EVENT_FLAGS.Bubbles */),composed:!!(flags&2/* EVENT_FLAGS.Composed */),cancelable:!!(flags&1/* EVENT_FLAGS.Cancellable */),detail});}};};/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */const emitEvent=(elm,name,opts)=>{const ev=plt.ce(name,opts);elm.dispatchEvent(ev);return ev;};const rootAppliedStyles=/*@__PURE__*/new WeakMap();const registerStyle=(scopeId,cssText,allowCS)=>{let style=styles.get(scopeId);if(supportsConstructableStylesheets&&allowCS){style=style||new CSSStyleSheet();if(typeof style==='string'){style=cssText;}else{style.replaceSync(cssText);}}else{style=cssText;}styles.set(scopeId,style);};const addStyle=(styleContainerNode,cmpMeta,mode,hostElm)=>{let scopeId=getScopeId(cmpMeta,mode);const style=styles.get(scopeId);if(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.attachStyles){return scopeId;}// if an element is NOT connected then getRootNode() will return the wrong root node\n// so the fallback is to always use the document for the root node in those cases\nstyleContainerNode=styleContainerNode.nodeType===11/* NODE_TYPE.DocumentFragment */?styleContainerNode:doc;if(style){if(typeof style==='string'){styleContainerNode=styleContainerNode.head||styleContainerNode;let appliedStyles=rootAppliedStyles.get(styleContainerNode);let styleElm;if(!appliedStyles){rootAppliedStyles.set(styleContainerNode,appliedStyles=new Set());}if(!appliedStyles.has(scopeId)){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide&&styleContainerNode.host&&(styleElm=styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))){// This is only happening on native shadow-dom, do not needs CSS var shim\nstyleElm.innerHTML=style;}else{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim&&plt.$cssShim$){styleElm=plt.$cssShim$.createHostStyle(hostElm,scopeId,style,!!(cmpMeta.$flags$&10/* CMP_FLAGS.needsScopedEncapsulation */));const newScopeId=styleElm['s-sc'];if(newScopeId){scopeId=newScopeId;// we don't want to add this styleID to the appliedStyles Set\n// since the cssVarShim might need to apply several different\n// stylesheets for the same component\nappliedStyles=null;}}else{styleElm=doc.createElement('style');styleElm.innerHTML=style;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement){styleElm.setAttribute(HYDRATED_STYLE_ID,scopeId);}styleContainerNode.insertBefore(styleElm,styleContainerNode.querySelector('link'));}if(appliedStyles){appliedStyles.add(scopeId);}}}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS&&!styleContainerNode.adoptedStyleSheets.includes(style)){styleContainerNode.adoptedStyleSheets=[...styleContainerNode.adoptedStyleSheets,style];}}return scopeId;};const attachStyles=hostRef=>{const cmpMeta=hostRef.$cmpMeta$;const elm=hostRef.$hostElement$;const flags=cmpMeta.$flags$;const endAttachStyles=createTime('attachStyles',cmpMeta.$tagName$);const scopeId=addStyle(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&supportsShadow&&elm.shadowRoot?elm.shadowRoot:elm.getRootNode(),cmpMeta,hostRef.$modeName$,elm);if((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped)&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations&&flags&10/* CMP_FLAGS.needsScopedEncapsulation */){// only required when we're NOT using native shadow dom (slot)\n// or this browser doesn't support native shadow dom\n// and this host element was NOT created with SSR\n// let's pick out the inner content for slot projection\n// create a node to represent where the original\n// content was first placed, which is useful later on\n// DOM WRITE!!\nelm['s-sc']=scopeId;elm.classList.add(scopeId+'-h');if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped&&flags&2/* CMP_FLAGS.scopedCssEncapsulation */){elm.classList.add(scopeId+'-s');}}endAttachStyles();};const getScopeId=(cmp,mode)=>'sc-'+(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode&&mode&&cmp.$flags$&32/* CMP_FLAGS.hasMode */?cmp.$tagName$+'-'+mode:cmp.$tagName$);const convertScopedToShadow=css=>css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g,'$1{');/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */const setAccessor=(elm,memberName,oldValue,newValue,isSvg,flags)=>{if(oldValue!==newValue){let isProp=isMemberInElement(elm,memberName);let ln=memberName.toLowerCase();if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass&&memberName==='class'){const classList=elm.classList;const oldClasses=parseClassList(oldValue);const newClasses=parseClassList(newValue);classList.remove(...oldClasses.filter(c=>c&&!newClasses.includes(c)));classList.add(...newClasses.filter(c=>c&&!oldClasses.includes(c)));}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomStyle&&memberName==='style'){// update style attribute, css properties and values\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable){for(const prop in oldValue){if(!newValue||newValue[prop]==null){if(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide&&prop.includes('-')){elm.style.removeProperty(prop);}else{elm.style[prop]='';}}}}for(const prop in newValue){if(!oldValue||newValue[prop]!==oldValue[prop]){if(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide&&prop.includes('-')){elm.style.setProperty(prop,newValue[prop]);}else{elm.style[prop]=newValue[prop];}}}}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey&&memberName==='key');else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef&&memberName==='ref'){// minifier will clean this up\nif(newValue){newValue(elm);}}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomListener&&(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad?!isProp:!elm.__lookupSetter__(memberName))&&memberName[0]==='o'&&memberName[1]==='n'){// Event Handlers\n// so if the member name starts with \"on\" and the 3rd characters is\n// a capital letter, and it's not already a member on the element,\n// then we're assuming it's an event listener\nif(memberName[2]==='-'){// on- prefixed events\n// allows to be explicit about the dom event to listen without any magic\n// under the hood:\n// <my-cmp on-click> // listens for \"click\"\n// <my-cmp on-Click> // listens for \"Click\"\n// <my-cmp on-ionChange> // listens for \"ionChange\"\n// <my-cmp on-EVENTS> // listens for \"EVENTS\"\nmemberName=memberName.slice(3);}else if(isMemberInElement(win,ln)){// standard event\n// the JSX attribute could have been \"onMouseOver\" and the\n// member name \"onmouseover\" is on the window's prototype\n// so let's add the listener \"mouseover\", which is all lowercased\nmemberName=ln.slice(2);}else{// custom event\n// the JSX attribute could have been \"onMyCustomEvent\"\n// so let's trim off the \"on\" prefix and lowercase the first character\n// and add the listener \"myCustomEvent\"\n// except for the first character, we keep the event name case\nmemberName=ln[2]+memberName.slice(3);}if(oldValue){plt.rel(elm,memberName,oldValue,false);}if(newValue){plt.ael(elm,memberName,newValue,false);}}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomPropOrAttr){// Set property if it exists and it's not a SVG\nconst isComplex=isComplexType(newValue);if((isProp||isComplex&&newValue!==null)&&!isSvg){try{if(!elm.tagName.includes('-')){const n=newValue==null?'':newValue;// Workaround for Safari, moving the <input> caret when re-assigning the same valued\nif(memberName==='list'){isProp=false;}else if(oldValue==null||elm[memberName]!=n){elm[memberName]=n;}}else{elm[memberName]=newValue;}}catch(e){}}/**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */let xlink=false;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink){if(ln!==(ln=ln.replace(/^xlink\\:?/,''))){memberName=ln;xlink=true;}}if(newValue==null||newValue===false){if(newValue!==false||elm.getAttribute(memberName)===''){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink&&xlink){elm.removeAttributeNS(XLINK_NS,memberName);}else{elm.removeAttribute(memberName);}}}else if((!isProp||flags&4/* VNODE_FLAGS.isHost */||isSvg)&&!isComplex){newValue=newValue===true?'':newValue;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink&&xlink){elm.setAttributeNS(XLINK_NS,memberName,newValue);}else{elm.setAttribute(memberName,newValue);}}}}};const parseClassListRegex=/\\s/;const parseClassList=value=>!value?[]:value.split(parseClassListRegex);const updateElement=(oldVnode,newVnode,isSvgMode,memberName)=>{// if the element passed in is a shadow root, which is a document fragment\n// then we want to be adding attrs/props to the shadow root's \"host\" element\n// if it's not a shadow root, then we add attrs/props to the same element\nconst elm=newVnode.$elm$.nodeType===11/* NODE_TYPE.DocumentFragment */&&newVnode.$elm$.host?newVnode.$elm$.host:newVnode.$elm$;const oldVnodeAttrs=oldVnode&&oldVnode.$attrs$||EMPTY_OBJ;const newVnodeAttrs=newVnode.$attrs$||EMPTY_OBJ;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable){// remove attributes no longer present on the vnode by setting them to undefined\nfor(memberName in oldVnodeAttrs){if(!(memberName in newVnodeAttrs)){setAccessor(elm,memberName,oldVnodeAttrs[memberName],undefined,isSvgMode,newVnode.$flags$);}}}// add new & update changed attributes\nfor(memberName in newVnodeAttrs){setAccessor(elm,memberName,oldVnodeAttrs[memberName],newVnodeAttrs[memberName],isSvgMode,newVnode.$flags$);}};/**\n * Create a DOM Node corresponding to one of the children of a given VNode.\n *\n * @param oldParentVNode the parent VNode from the previous render\n * @param newParentVNode the parent VNode from the current render\n * @param childIndex the index of the VNode, in the _new_ parent node's\n * children, for which we will create a new DOM node\n * @param parentElm the parent DOM node which our new node will be a child of\n * @returns the newly created node\n */const createElm=(oldParentVNode,newParentVNode,childIndex,parentElm)=>{// tslint:disable-next-line: prefer-const\nconst newVNode=newParentVNode.$children$[childIndex];let i=0;let elm;let childNode;let oldVNode;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&!useNativeShadowDom){// remember for later we need to check to relocate nodes\ncheckSlotRelocate=true;if(newVNode.$tag$==='slot'){if(scopeId){// scoped css needs to add its scoped id to the parent element\nparentElm.classList.add(scopeId+'-s');}newVNode.$flags$|=newVNode.$children$?// slot element has fallback content\n2/* VNODE_FLAGS.isSlotFallback */:// slot element does not have fallback content\n1/* VNODE_FLAGS.isSlotReference */;}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev&&newVNode.$elm$){consoleDevError(`The JSX ${newVNode.$text$!==null?`\"${newVNode.$text$}\" text`:`\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText&&newVNode.$text$!==null){// create text node\nelm=newVNode.$elm$=doc.createTextNode(newVNode.$text$);}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&newVNode.$flags$&1/* VNODE_FLAGS.isSlotReference */){// create a slot reference node\nelm=newVNode.$elm$=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide?slotReferenceDebugNode(newVNode):doc.createTextNode('');}else{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg&&!isSvgMode){isSvgMode=newVNode.$tag$==='svg';}// create element\nelm=newVNode.$elm$=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg?doc.createElementNS(isSvgMode?SVG_NS:HTML_NS,_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&newVNode.$flags$&2/* VNODE_FLAGS.isSlotFallback */?'slot-fb':newVNode.$tag$):doc.createElement(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&newVNode.$flags$&2/* VNODE_FLAGS.isSlotFallback */?'slot-fb':newVNode.$tag$);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg&&isSvgMode&&newVNode.$tag$==='foreignObject'){isSvgMode=false;}// add css classes, attrs, props, listeners, etc.\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute){updateElement(null,newVNode,isSvgMode);}if((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped)&&isDef(scopeId)&&elm['s-si']!==scopeId){// if there is a scopeId and this is the initial render\n// then let's add the scopeId as a css class\nelm.classList.add(elm['s-si']=scopeId);}if(newVNode.$children$){for(i=0;i<newVNode.$children$.length;++i){// create the node\nchildNode=createElm(oldParentVNode,newVNode,i,elm);// return node could have been null\nif(childNode){// append our new node\nelm.appendChild(childNode);}}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg){if(newVNode.$tag$==='svg'){// Only reset the SVG context when we're exiting <svg> element\nisSvgMode=false;}else if(elm.tagName==='foreignObject'){// Reenter SVG context when we're exiting <foreignObject> element\nisSvgMode=true;}}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation){elm['s-hn']=hostTagName;if(newVNode.$flags$&(2/* VNODE_FLAGS.isSlotFallback */|1/* VNODE_FLAGS.isSlotReference */)){// remember the content reference comment\nelm['s-sr']=true;// remember the content reference comment\nelm['s-cr']=contentRef;// remember the slot name, or empty string for default slot\nelm['s-sn']=newVNode.$name$||'';// check if we've got an old vnode for this slot\noldVNode=oldParentVNode&&oldParentVNode.$children$&&oldParentVNode.$children$[childIndex];if(oldVNode&&oldVNode.$tag$===newVNode.$tag$&&oldParentVNode.$elm$){// we've got an old slot vnode and the wrapper is being replaced\n// so let's move the old slot content back to it's original location\nputBackInOriginalLocation(oldParentVNode.$elm$,false);}}}return elm;};const putBackInOriginalLocation=(parentElm,recursive)=>{plt.$flags$|=1/* PLATFORM_FLAGS.isTmpDisconnected */;const oldSlotChildNodes=parentElm.childNodes;for(let i=oldSlotChildNodes.length-1;i>=0;i--){const childNode=oldSlotChildNodes[i];if(childNode['s-hn']!==hostTagName&&childNode['s-ol']){// // this child node in the old element is from another component\n// // remove this node from the old slot's parent\n// childNode.remove();\n// and relocate it back to it's original location\nparentReferenceNode(childNode).insertBefore(childNode,referenceNode(childNode));// remove the old original location comment entirely\n// later on the patch function will know what to do\n// and move this to the correct spot in need be\nchildNode['s-ol'].remove();childNode['s-ol']=undefined;checkSlotRelocate=true;}if(recursive){putBackInOriginalLocation(childNode,recursive);}}plt.$flags$&=~1/* PLATFORM_FLAGS.isTmpDisconnected */;};const addVnodes=(parentElm,before,parentVNode,vnodes,startIdx,endIdx)=>{let containerElm=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&parentElm['s-cr']&&parentElm['s-cr'].parentNode||parentElm;let childNode;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&containerElm.shadowRoot&&containerElm.tagName===hostTagName){containerElm=containerElm.shadowRoot;}for(;startIdx<=endIdx;++startIdx){if(vnodes[startIdx]){childNode=createElm(null,parentVNode,startIdx,parentElm);if(childNode){vnodes[startIdx].$elm$=childNode;containerElm.insertBefore(childNode,_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation?referenceNode(before):before);}}}};const removeVnodes=(vnodes,startIdx,endIdx,vnode,elm)=>{for(;startIdx<=endIdx;++startIdx){if(vnode=vnodes[startIdx]){elm=vnode.$elm$;callNodeRefs(vnode);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation){// we're removing this element\n// so it's possible we need to show slot fallback content now\ncheckSlotFallbackVisibility=true;if(elm['s-ol']){// remove the original location comment\nelm['s-ol'].remove();}else{// it's possible that child nodes of the node\n// that's being removed are slot nodes\nputBackInOriginalLocation(elm,true);}}// remove the vnode's element from the dom\nelm.remove();}}};/**\n * Reconcile the children of a new VNode with the children of an old VNode by\n * traversing the two collections of children, identifying nodes that are\n * conserved or changed, calling out to `patch` to make any necessary\n * updates to the DOM, and rearranging DOM nodes as needed.\n *\n * The algorithm for reconciling children works by analyzing two 'windows' onto\n * the two arrays of children (`oldCh` and `newCh`). We keep track of the\n * 'windows' by storing start and end indices and references to the\n * corresponding array entries. Initially the two 'windows' are basically equal\n * to the entire array, but we progressively narrow the windows until there are\n * no children left to update by doing the following:\n *\n * 1. Skip any `null` entries at the beginning or end of the two arrays, so\n *    that if we have an initial array like the following we'll end up dealing\n *    only with a window bounded by the highlighted elements:\n *\n *    [null, null, VNode1 , ... , VNode2, null, null]\n *                 ^^^^^^         ^^^^^^\n *\n * 2. Check to see if the elements at the head and tail positions are equal\n *    across the windows. This will basically detect elements which haven't\n *    been added, removed, or changed position, i.e. if you had the following\n *    VNode elements (represented as HTML):\n *\n *    oldVNode: `<div><p><span>HEY</span></p></div>`\n *    newVNode: `<div><p><span>THERE</span></p></div>`\n *\n *    Then when comparing the children of the `<div>` tag we check the equality\n *    of the VNodes corresponding to the `<p>` tags and, since they are the\n *    same tag in the same position, we'd be able to avoid completely\n *    re-rendering the subtree under them with a new DOM element and would just\n *    call out to `patch` to handle reconciling their children and so on.\n *\n * 3. Check, for both windows, to see if the element at the beginning of the\n *    window corresponds to the element at the end of the other window. This is\n *    a heuristic which will let us identify _some_ situations in which\n *    elements have changed position, for instance it _should_ detect that the\n *    children nodes themselves have not changed but merely moved in the\n *    following example:\n *\n *    oldVNode: `<div><element-one /><element-two /></div>`\n *    newVNode: `<div><element-two /><element-one /></div>`\n *\n *    If we find cases like this then we also need to move the concrete DOM\n *    elements corresponding to the moved children to write the re-order to the\n *    DOM.\n *\n * 4. Finally, if VNodes have the `key` attribute set on them we check for any\n *    nodes in the old children which have the same key as the first element in\n *    our window on the new children. If we find such a node we handle calling\n *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with\n *    what we find.\n *\n * Finally, once we've narrowed our 'windows' to the point that either of them\n * collapse (i.e. they have length 0) we then handle any remaining VNode\n * insertion or deletion that needs to happen to get a DOM state that correctly\n * reflects the new child VNodes. If, for instance, after our window on the old\n * children has collapsed we still have more nodes on the new children that\n * we haven't dealt with yet then we need to add them, or if the new children\n * collapse but we still have unhandled _old_ children then we need to make\n * sure the corresponding DOM nodes are removed.\n *\n * @param parentElm the node into which the parent VNode is rendered\n * @param oldCh the old children of the parent node\n * @param newVNode the new VNode which will replace the parent\n * @param newCh the new children of the parent node\n */const updateChildren=(parentElm,oldCh,newVNode,newCh)=>{let oldStartIdx=0;let newStartIdx=0;let idxInOld=0;let i=0;let oldEndIdx=oldCh.length-1;let oldStartVnode=oldCh[0];let oldEndVnode=oldCh[oldEndIdx];let newEndIdx=newCh.length-1;let newStartVnode=newCh[0];let newEndVnode=newCh[newEndIdx];let node;let elmToMove;while(oldStartIdx<=oldEndIdx&&newStartIdx<=newEndIdx){if(oldStartVnode==null){// VNode might have been moved left\noldStartVnode=oldCh[++oldStartIdx];}else if(oldEndVnode==null){oldEndVnode=oldCh[--oldEndIdx];}else if(newStartVnode==null){newStartVnode=newCh[++newStartIdx];}else if(newEndVnode==null){newEndVnode=newCh[--newEndIdx];}else if(isSameVnode(oldStartVnode,newStartVnode)){// if the start nodes are the same then we should patch the new VNode\n// onto the old one, and increment our `newStartIdx` and `oldStartIdx`\n// indices to reflect that. We don't need to move any DOM Nodes around\n// since things are matched up in order.\npatch(oldStartVnode,newStartVnode);oldStartVnode=oldCh[++oldStartIdx];newStartVnode=newCh[++newStartIdx];}else if(isSameVnode(oldEndVnode,newEndVnode)){// likewise, if the end nodes are the same we patch new onto old and\n// decrement our end indices, and also likewise in this case we don't\n// need to move any DOM Nodes.\npatch(oldEndVnode,newEndVnode);oldEndVnode=oldCh[--oldEndIdx];newEndVnode=newCh[--newEndIdx];}else if(isSameVnode(oldStartVnode,newEndVnode)){// case: \"Vnode moved right\"\n//\n// We've found that the last node in our window on the new children is\n// the same VNode as the _first_ node in our window on the old children\n// we're dealing with now. Visually, this is the layout of these two\n// nodes:\n//\n// newCh: [..., newStartVnode , ... , newEndVnode , ...]\n//                                    ^^^^^^^^^^^\n// oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]\n//              ^^^^^^^^^^^^^\n//\n// In this situation we need to patch `newEndVnode` onto `oldStartVnode`\n// and move the DOM element for `oldStartVnode`.\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&(oldStartVnode.$tag$==='slot'||newEndVnode.$tag$==='slot')){putBackInOriginalLocation(oldStartVnode.$elm$.parentNode,false);}patch(oldStartVnode,newEndVnode);// We need to move the element for `oldStartVnode` into a position which\n// will be appropriate for `newEndVnode`. For this we can use\n// `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a\n// sibling for `oldEndVnode.$elm$` then we want to move the DOM node for\n// `oldStartVnode` between `oldEndVnode` and it's sibling, like so:\n//\n// <old-start-node />\n// <some-intervening-node />\n// <old-end-node />\n// <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here\n// <next-sibling />\n//\n// If instead `oldEndVnode.$elm$` has no sibling then we just want to put\n// the node for `oldStartVnode` at the end of the children of\n// `parentElm`. Luckily, `Node.nextSibling` will return `null` if there\n// aren't any siblings, and passing `null` to `Node.insertBefore` will\n// append it to the children of the parent element.\nparentElm.insertBefore(oldStartVnode.$elm$,oldEndVnode.$elm$.nextSibling);oldStartVnode=oldCh[++oldStartIdx];newEndVnode=newCh[--newEndIdx];}else if(isSameVnode(oldEndVnode,newStartVnode)){// case: \"Vnode moved left\"\n//\n// We've found that the first node in our window on the new children is\n// the same VNode as the _last_ node in our window on the old children.\n// Visually, this is the layout of these two nodes:\n//\n// newCh: [..., newStartVnode , ... , newEndVnode , ...]\n//              ^^^^^^^^^^^^^\n// oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]\n//                                    ^^^^^^^^^^^\n//\n// In this situation we need to patch `newStartVnode` onto `oldEndVnode`\n// (which will handle updating any changed attributes, reconciling their\n// children etc) but we also need to move the DOM node to which\n// `oldEndVnode` corresponds.\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&(oldStartVnode.$tag$==='slot'||newEndVnode.$tag$==='slot')){putBackInOriginalLocation(oldEndVnode.$elm$.parentNode,false);}patch(oldEndVnode,newStartVnode);// We've already checked above if `oldStartVnode` and `newStartVnode` are\n// the same node, so since we're here we know that they are not. Thus we\n// can move the element for `oldEndVnode` _before_ the element for\n// `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the\n// future.\nparentElm.insertBefore(oldEndVnode.$elm$,oldStartVnode.$elm$);oldEndVnode=oldCh[--oldEndIdx];newStartVnode=newCh[++newStartIdx];}else{// Here we do some checks to match up old and new nodes based on the\n// `$key$` attribute, which is set by putting a `key=\"my-key\"` attribute\n// in the JSX for a DOM element in the implementation of a Stencil\n// component.\n//\n// First we check to see if there are any nodes in the array of old\n// children which have the same key as the first node in the new\n// children.\nidxInOld=-1;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey){for(i=oldStartIdx;i<=oldEndIdx;++i){if(oldCh[i]&&oldCh[i].$key$!==null&&oldCh[i].$key$===newStartVnode.$key$){idxInOld=i;break;}}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey&&idxInOld>=0){// We found a node in the old children which matches up with the first\n// node in the new children! So let's deal with that\nelmToMove=oldCh[idxInOld];if(elmToMove.$tag$!==newStartVnode.$tag$){// the tag doesn't match so we'll need a new DOM element\nnode=createElm(oldCh&&oldCh[newStartIdx],newVNode,idxInOld,parentElm);}else{patch(elmToMove,newStartVnode);// invalidate the matching old node so that we won't try to update it\n// again later on\noldCh[idxInOld]=undefined;node=elmToMove.$elm$;}newStartVnode=newCh[++newStartIdx];}else{// We either didn't find an element in the old children that matches\n// the key of the first new child OR the build is not using `key`\n// attributes at all. In either case we need to create a new element\n// for the new node.\nnode=createElm(oldCh&&oldCh[newStartIdx],newVNode,newStartIdx,parentElm);newStartVnode=newCh[++newStartIdx];}if(node){// if we created a new node then handle inserting it to the DOM\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation){parentReferenceNode(oldStartVnode.$elm$).insertBefore(node,referenceNode(oldStartVnode.$elm$));}else{oldStartVnode.$elm$.parentNode.insertBefore(node,oldStartVnode.$elm$);}}}}if(oldStartIdx>oldEndIdx){// we have some more new nodes to add which don't match up with old nodes\naddVnodes(parentElm,newCh[newEndIdx+1]==null?null:newCh[newEndIdx+1].$elm$,newVNode,newCh,newStartIdx,newEndIdx);}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable&&newStartIdx>newEndIdx){// there are nodes in the `oldCh` array which no longer correspond to nodes\n// in the new array, so lets remove them (which entails cleaning up the\n// relevant DOM nodes)\nremoveVnodes(oldCh,oldStartIdx,oldEndIdx);}};/**\n * Compare two VNodes to determine if they are the same\n *\n * **NB**: This function is an equality _heuristic_ based on the available\n * information set on the two VNodes and can be misleading under certain\n * circumstances. In particular, if the two nodes do not have `key` attrs\n * (available under `$key$` on VNodes) then the function falls back on merely\n * checking that they have the same tag.\n *\n * So, in other words, if `key` attrs are not set on VNodes which may be\n * changing order within a `children` array or something along those lines then\n * we could obtain a false positive and then have to do needless re-rendering.\n *\n * @param leftVNode the first VNode to check\n * @param rightVNode the second VNode to check\n * @returns whether they're equal or not\n */const isSameVnode=(leftVNode,rightVNode)=>{// compare if two vnode to see if they're \"technically\" the same\n// need to have the same element tag, and same key to be the same\nif(leftVNode.$tag$===rightVNode.$tag$){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&leftVNode.$tag$==='slot'){return leftVNode.$name$===rightVNode.$name$;}// this will be set if components in the build have `key` attrs set on them\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey){return leftVNode.$key$===rightVNode.$key$;}return true;}return false;};const referenceNode=node=>{// this node was relocated to a new location in the dom\n// because of some other component's slot\n// but we still have an html comment in place of where\n// it's original location was according to it's original vdom\nreturn node&&node['s-ol']||node;};const parentReferenceNode=node=>(node['s-ol']?node['s-ol']:node).parentNode;/**\n * Handle reconciling an outdated VNode with a new one which corresponds to\n * it. This function handles flushing updates to the DOM and reconciling the\n * children of the two nodes (if any).\n *\n * @param oldVNode an old VNode whose DOM element and children we want to update\n * @param newVNode a new VNode representing an updated version of the old one\n */const patch=(oldVNode,newVNode)=>{const elm=newVNode.$elm$=oldVNode.$elm$;const oldChildren=oldVNode.$children$;const newChildren=newVNode.$children$;const tag=newVNode.$tag$;const text=newVNode.$text$;let defaultHolder;if(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText||text===null){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg){// test if we're rendering an svg element, or still rendering nodes inside of one\n// only add this to the when the compiler sees we're using an svg somewhere\nisSvgMode=tag==='svg'?true:tag==='foreignObject'?false:isSvgMode;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot&&tag==='slot');else{// either this is the first render of an element OR it's an update\n// AND we already know it's possible it could have changed\n// this updates the element's css classes, attrs, props, listeners, etc.\nupdateElement(oldVNode,newVNode,isSvgMode);}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable&&oldChildren!==null&&newChildren!==null){// looks like there's child vnodes for both the old and new vnodes\n// so we need to call `updateChildren` to reconcile them\nupdateChildren(elm,oldChildren,newVNode,newChildren);}else if(newChildren!==null){// no old child vnodes, but there are new child vnodes to add\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText&&oldVNode.$text$!==null){// the old vnode was text, so be sure to clear it out\nelm.textContent='';}// add the new vnode children\naddVnodes(elm,null,newVNode,newChildren,0,newChildren.length-1);}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable&&oldChildren!==null){// no new child vnodes, but there are old child vnodes to remove\nremoveVnodes(oldChildren,0,oldChildren.length-1);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg&&isSvgMode&&tag==='svg'){isSvgMode=false;}}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&(defaultHolder=elm['s-cr'])){// this element has slotted content\ndefaultHolder.parentNode.textContent=text;}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText&&oldVNode.$text$!==text){// update the text content for the text only vnode\n// and also only if the text is different than before\nelm.data=text;}};const updateFallbackSlotVisibility=elm=>{// tslint:disable-next-line: prefer-const\nconst childNodes=elm.childNodes;let childNode;let i;let ilen;let j;let slotNameAttr;let nodeType;for(i=0,ilen=childNodes.length;i<ilen;i++){childNode=childNodes[i];if(childNode.nodeType===1/* NODE_TYPE.ElementNode */){if(childNode['s-sr']){// this is a slot fallback node\n// get the slot name for this slot reference node\nslotNameAttr=childNode['s-sn'];// by default always show a fallback slot node\n// then hide it if there are other slots in the light dom\nchildNode.hidden=false;for(j=0;j<ilen;j++){nodeType=childNodes[j].nodeType;if(childNodes[j]['s-hn']!==childNode['s-hn']||slotNameAttr!==''){// this sibling node is from a different component OR is a named fallback slot node\nif(nodeType===1/* NODE_TYPE.ElementNode */&&slotNameAttr===childNodes[j].getAttribute('slot')){childNode.hidden=true;break;}}else{// this is a default fallback slot node\n// any element or text node (with content)\n// should hide the default fallback slot node\nif(nodeType===1/* NODE_TYPE.ElementNode */||nodeType===3/* NODE_TYPE.TextNode */&&childNodes[j].textContent.trim()!==''){childNode.hidden=true;break;}}}}// keep drilling down\nupdateFallbackSlotVisibility(childNode);}}};const relocateNodes=[];const relocateSlotContent=elm=>{// tslint:disable-next-line: prefer-const\nlet childNode;let node;let hostContentNodes;let slotNameAttr;let relocateNodeData;let j;let i=0;const childNodes=elm.childNodes;const ilen=childNodes.length;for(;i<ilen;i++){childNode=childNodes[i];if(childNode['s-sr']&&(node=childNode['s-cr'])&&node.parentNode){// first got the content reference comment node\n// then we got it's parent, which is where all the host content is in now\nhostContentNodes=node.parentNode.childNodes;slotNameAttr=childNode['s-sn'];for(j=hostContentNodes.length-1;j>=0;j--){node=hostContentNodes[j];if(!node['s-cn']&&!node['s-nr']&&node['s-hn']!==childNode['s-hn']){// let's do some relocating to its new home\n// but never relocate a content reference node\n// that is suppose to always represent the original content location\nif(isNodeLocatedInSlot(node,slotNameAttr)){// it's possible we've already decided to relocate this node\nrelocateNodeData=relocateNodes.find(r=>r.$nodeToRelocate$===node);// made some changes to slots\n// let's make sure we also double check\n// fallbacks are correctly hidden or shown\ncheckSlotFallbackVisibility=true;node['s-sn']=node['s-sn']||slotNameAttr;if(relocateNodeData){// previously we never found a slot home for this node\n// but turns out we did, so let's remember it now\nrelocateNodeData.$slotRefNode$=childNode;}else{// add to our list of nodes to relocate\nrelocateNodes.push({$slotRefNode$:childNode,$nodeToRelocate$:node});}if(node['s-sr']){relocateNodes.map(relocateNode=>{if(isNodeLocatedInSlot(relocateNode.$nodeToRelocate$,node['s-sn'])){relocateNodeData=relocateNodes.find(r=>r.$nodeToRelocate$===node);if(relocateNodeData&&!relocateNode.$slotRefNode$){relocateNode.$slotRefNode$=relocateNodeData.$slotRefNode$;}}});}}else if(!relocateNodes.some(r=>r.$nodeToRelocate$===node)){// so far this element does not have a slot home, not setting slotRefNode on purpose\n// if we never find a home for this element then we'll need to hide it\nrelocateNodes.push({$nodeToRelocate$:node});}}}}if(childNode.nodeType===1/* NODE_TYPE.ElementNode */){relocateSlotContent(childNode);}}};const isNodeLocatedInSlot=(nodeToRelocate,slotNameAttr)=>{if(nodeToRelocate.nodeType===1/* NODE_TYPE.ElementNode */){if(nodeToRelocate.getAttribute('slot')===null&&slotNameAttr===''){return true;}if(nodeToRelocate.getAttribute('slot')===slotNameAttr){return true;}return false;}if(nodeToRelocate['s-sn']===slotNameAttr){return true;}return slotNameAttr==='';};const callNodeRefs=vNode=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef){vNode.$attrs$&&vNode.$attrs$.ref&&vNode.$attrs$.ref(null);vNode.$children$&&vNode.$children$.map(callNodeRefs);}};const renderVdom=(hostRef,renderFnResults)=>{const hostElm=hostRef.$hostElement$;const cmpMeta=hostRef.$cmpMeta$;const oldVNode=hostRef.$vnode$||newVNode(null,null);const rootVnode=isHost(renderFnResults)?renderFnResults:h(null,null,renderFnResults);hostTagName=hostElm.tagName;// <Host> runtime check\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev&&Array.isArray(renderFnResults)&&renderFnResults.some(isHost)){throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect&&cmpMeta.$attrsToReflect$){rootVnode.$attrs$=rootVnode.$attrs$||{};cmpMeta.$attrsToReflect$.map(_ref2=>{let[propName,attribute]=_ref2;return rootVnode.$attrs$[attribute]=hostElm[propName];});}rootVnode.$tag$=null;rootVnode.$flags$|=4/* VNODE_FLAGS.isHost */;hostRef.$vnode$=rootVnode;rootVnode.$elm$=oldVNode.$elm$=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom?hostElm.shadowRoot||hostElm:hostElm;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom){scopeId=hostElm['s-sc'];}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation){contentRef=hostElm['s-cr'];useNativeShadowDom=supportsShadow&&(cmpMeta.$flags$&1/* CMP_FLAGS.shadowDomEncapsulation */)!==0;// always reset\ncheckSlotFallbackVisibility=false;}// synchronous patch\npatch(oldVNode,rootVnode);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation){// while we're moving nodes around existing nodes, temporarily disable\n// the disconnectCallback from working\nplt.$flags$|=1/* PLATFORM_FLAGS.isTmpDisconnected */;if(checkSlotRelocate){relocateSlotContent(rootVnode.$elm$);let relocateData;let nodeToRelocate;let orgLocationNode;let parentNodeRef;let insertBeforeNode;let refNode;let i=0;for(;i<relocateNodes.length;i++){relocateData=relocateNodes[i];nodeToRelocate=relocateData.$nodeToRelocate$;if(!nodeToRelocate['s-ol']){// add a reference node marking this node's original location\n// keep a reference to this node for later lookups\norgLocationNode=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide?originalLocationDebugNode(nodeToRelocate):doc.createTextNode('');orgLocationNode['s-nr']=nodeToRelocate;nodeToRelocate.parentNode.insertBefore(nodeToRelocate['s-ol']=orgLocationNode,nodeToRelocate);}}for(i=0;i<relocateNodes.length;i++){relocateData=relocateNodes[i];nodeToRelocate=relocateData.$nodeToRelocate$;if(relocateData.$slotRefNode$){// by default we're just going to insert it directly\n// after the slot reference node\nparentNodeRef=relocateData.$slotRefNode$.parentNode;insertBeforeNode=relocateData.$slotRefNode$.nextSibling;orgLocationNode=nodeToRelocate['s-ol'];while(orgLocationNode=orgLocationNode.previousSibling){refNode=orgLocationNode['s-nr'];if(refNode&&refNode['s-sn']===nodeToRelocate['s-sn']&&parentNodeRef===refNode.parentNode){refNode=refNode.nextSibling;if(!refNode||!refNode['s-nr']){insertBeforeNode=refNode;break;}}}if(!insertBeforeNode&&parentNodeRef!==nodeToRelocate.parentNode||nodeToRelocate.nextSibling!==insertBeforeNode){// we've checked that it's worth while to relocate\n// since that the node to relocate\n// has a different next sibling or parent relocated\nif(nodeToRelocate!==insertBeforeNode){if(!nodeToRelocate['s-hn']&&nodeToRelocate['s-ol']){// probably a component in the index.html that doesn't have it's hostname set\nnodeToRelocate['s-hn']=nodeToRelocate['s-ol'].parentNode.nodeName;}// add it back to the dom but in its new home\nparentNodeRef.insertBefore(nodeToRelocate,insertBeforeNode);}}}else{// this node doesn't have a slot home to go to, so let's hide it\nif(nodeToRelocate.nodeType===1/* NODE_TYPE.ElementNode */){nodeToRelocate.hidden=true;}}}}if(checkSlotFallbackVisibility){updateFallbackSlotVisibility(rootVnode.$elm$);}// done moving nodes around\n// allow the disconnect callback to work again\nplt.$flags$&=~1/* PLATFORM_FLAGS.isTmpDisconnected */;// always reset\nrelocateNodes.length=0;}};// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode=slotVNode=>doc.createComment(`<slot${slotVNode.$name$?' name=\"'+slotVNode.$name$+'\"':''}> (host=${hostTagName.toLowerCase()})`);const originalLocationDebugNode=nodeToRelocate=>doc.createComment(`org-location for `+(nodeToRelocate.localName?`<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`:`[${nodeToRelocate.textContent}]`));const attachToAncestor=(hostRef,ancestorComponent)=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading&&ancestorComponent&&!hostRef.$onRenderResolve$&&ancestorComponent['s-p']){ancestorComponent['s-p'].push(new Promise(r=>hostRef.$onRenderResolve$=r));}};const scheduleUpdate=(hostRef,isInitialLoad)=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable){hostRef.$flags$|=16/* HOST_FLAGS.isQueuedForUpdate */;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading&&hostRef.$flags$&4/* HOST_FLAGS.isWaitingForChildren */){hostRef.$flags$|=512/* HOST_FLAGS.needsRerender */;return;}attachToAncestor(hostRef,hostRef.$ancestorComponent$);// there is no ancestor component or the ancestor component\n// has already fired off its lifecycle update then\n// fire off the initial update\nconst dispatch=()=>dispatchHooks(hostRef,isInitialLoad);return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue?writeTask(dispatch):dispatch();};const dispatchHooks=(hostRef,isInitialLoad)=>{const elm=hostRef.$hostElement$;const endSchedule=createTime('scheduleUpdate',hostRef.$cmpMeta$.$tagName$);const instance=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad?hostRef.$lazyInstance$:elm;let promise;if(isInitialLoad){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener){hostRef.$flags$|=256/* HOST_FLAGS.isListenReady */;if(hostRef.$queuedListeners$){hostRef.$queuedListeners$.map(_ref3=>{let[methodName,event]=_ref3;return safeCall(instance,methodName,event);});hostRef.$queuedListeners$=null;}}emitLifecycleEvent(elm,'componentWillLoad');if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillLoad){promise=safeCall(instance,'componentWillLoad');}}else{emitLifecycleEvent(elm,'componentWillUpdate');if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillUpdate){promise=safeCall(instance,'componentWillUpdate');}}emitLifecycleEvent(elm,'componentWillRender');if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillRender){promise=then(promise,()=>safeCall(instance,'componentWillRender'));}endSchedule();return then(promise,()=>updateComponent(hostRef,instance,isInitialLoad));};const updateComponent=async(hostRef,instance,isInitialLoad)=>{// updateComponent\nconst elm=hostRef.$hostElement$;const endUpdate=createTime('update',hostRef.$cmpMeta$.$tagName$);const rc=elm['s-rc'];if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style&&isInitialLoad){// DOM WRITE!\nattachStyles(hostRef);}const endRender=createTime('render',hostRef.$cmpMeta$.$tagName$);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$flags$|=1024/* HOST_FLAGS.devOnRender */;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide){await callRender(hostRef,instance,elm);}else{callRender(hostRef,instance,elm);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim&&plt.$cssShim$){plt.$cssShim$.updateHost(elm);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$renderCount$++;hostRef.$flags$&=~1024/* HOST_FLAGS.devOnRender */;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide){try{// manually connected child components during server-side hydrate\nserverSideConnected(elm);if(isInitialLoad){// using only during server-side hydrate\nif(hostRef.$cmpMeta$.$flags$&1/* CMP_FLAGS.shadowDomEncapsulation */){elm['s-en']='';}else if(hostRef.$cmpMeta$.$flags$&2/* CMP_FLAGS.scopedCssEncapsulation */){elm['s-en']='c';}}}catch(e){consoleError(e,elm);}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading&&rc){// ok, so turns out there are some child host elements\n// waiting on this parent element to load\n// let's fire off all update callbacks waiting\nrc.map(cb=>cb());elm['s-rc']=undefined;}endRender();endUpdate();if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading){const childrenPromises=elm['s-p'];const postUpdate=()=>postUpdateComponent(hostRef);if(childrenPromises.length===0){postUpdate();}else{Promise.all(childrenPromises).then(postUpdate);hostRef.$flags$|=4/* HOST_FLAGS.isWaitingForChildren */;childrenPromises.length=0;}}else{postUpdateComponent(hostRef);}};const callRender=(hostRef,instance,elm)=>{// in order for bundlers to correctly treeshake the BUILD object\n// we need to ensure BUILD is not deoptimized within a try/catch\n// https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\nconst allRenderFn=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.allRenderFn?true:false;const lazyLoad=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad?true:false;const taskQueue=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue?true:false;const updatable=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable?true:false;try{renderingRef=instance;instance=allRenderFn?instance.render():instance.render&&instance.render();if(updatable&&taskQueue){hostRef.$flags$&=~16/* HOST_FLAGS.isQueuedForUpdate */;}if(updatable||lazyLoad){hostRef.$flags$|=2/* HOST_FLAGS.hasRendered */;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hasRenderFn||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRender||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect){// looks like we've got child nodes to render into this host element\n// or we need to update the css class/attrs on the host element\n// DOM WRITE!\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide){return Promise.resolve(instance).then(value=>renderVdom(hostRef,value));}else{renderVdom(hostRef,instance);}}else{elm.textContent=instance;}}}catch(e){consoleError(e,hostRef.$hostElement$);}renderingRef=null;return null;};const getRenderingRef=()=>renderingRef;const postUpdateComponent=hostRef=>{const tagName=hostRef.$cmpMeta$.$tagName$;const elm=hostRef.$hostElement$;const endPostUpdate=createTime('postUpdate',tagName);const instance=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad?hostRef.$lazyInstance$:elm;const ancestorComponent=hostRef.$ancestorComponent$;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidRender){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$flags$|=1024/* HOST_FLAGS.devOnRender */;}safeCall(instance,'componentDidRender');if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$flags$&=~1024/* HOST_FLAGS.devOnRender */;}}emitLifecycleEvent(elm,'componentDidRender');if(!(hostRef.$flags$&64/* HOST_FLAGS.hasLoadedComponent */)){hostRef.$flags$|=64/* HOST_FLAGS.hasLoadedComponent */;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations){// DOM WRITE!\naddHydratedFlag(elm);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidLoad){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$flags$|=2048/* HOST_FLAGS.devOnDidLoad */;}safeCall(instance,'componentDidLoad');if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$flags$&=~2048/* HOST_FLAGS.devOnDidLoad */;}}emitLifecycleEvent(elm,'componentDidLoad');endPostUpdate();if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading){hostRef.$onReadyResolve$(elm);if(!ancestorComponent){appDidLoad(tagName);}}}else{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUpdate){// we've already loaded this component\n// fire off the user's componentDidUpdate method (if one was provided)\n// componentDidUpdate runs AFTER render() has been called\n// and all child components have finished updating\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$flags$|=1024/* HOST_FLAGS.devOnRender */;}safeCall(instance,'componentDidUpdate');if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$flags$&=~1024/* HOST_FLAGS.devOnRender */;}}emitLifecycleEvent(elm,'componentDidUpdate');endPostUpdate();}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement){elm['s-hmr-load']&&elm['s-hmr-load']();}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad){hostRef.$onInstanceResolve$(elm);}// load events fire from bottom to top\n// the deepest elements load first then bubbles up\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading){if(hostRef.$onRenderResolve$){hostRef.$onRenderResolve$();hostRef.$onRenderResolve$=undefined;}if(hostRef.$flags$&512/* HOST_FLAGS.needsRerender */){nextTick(()=>scheduleUpdate(hostRef,false));}hostRef.$flags$&=~(4/* HOST_FLAGS.isWaitingForChildren */|512/* HOST_FLAGS.needsRerender */);}// ( •_•)\n// ( •_•)>⌐■-■\n// (⌐■_■)\n};const forceUpdate=ref=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable){const hostRef=getHostRef(ref);const isConnected=hostRef.$hostElement$.isConnected;if(isConnected&&(hostRef.$flags$&(2/* HOST_FLAGS.hasRendered */|16/* HOST_FLAGS.isQueuedForUpdate */))===2/* HOST_FLAGS.hasRendered */){scheduleUpdate(hostRef,false);}// Returns \"true\" when the forced update was successfully scheduled\nreturn isConnected;}return false;};const appDidLoad=who=>{// on appload\n// we have finish the first big initial render\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations){addHydratedFlag(doc.documentElement);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue){plt.$flags$|=2/* PLATFORM_FLAGS.appLoaded */;}nextTick(()=>emitEvent(win,'appload',{detail:{namespace:_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE}}));if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile&&performance.measure){performance.measure(`[Stencil] ${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE} initial load (by ${who})`,'st:app:start');}};const safeCall=(instance,method,arg)=>{if(instance&&instance[method]){try{return instance[method](arg);}catch(e){consoleError(e);}}return undefined;};const then=(promise,thenFn)=>{return promise&&promise.then?promise.then(thenFn):thenFn();};const emitLifecycleEvent=(elm,lifecycleName)=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lifecycleDOMEvents){emitEvent(elm,'stencil_'+lifecycleName,{bubbles:true,composed:true,detail:{namespace:_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE}});}};const addHydratedFlag=elm=>_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass?elm.classList.add('hydrated'):_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute?elm.setAttribute('hydrated',''):undefined;const serverSideConnected=elm=>{const children=elm.children;if(children!=null){for(let i=0,ii=children.length;i<ii;i++){const childElm=children[i];if(typeof childElm.connectedCallback==='function'){childElm.connectedCallback();}serverSideConnected(childElm);}}};const getValue=(ref,propName)=>getHostRef(ref).$instanceValues$.get(propName);const setValue=(ref,propName,newVal,cmpMeta)=>{// check our new property value against our internal value\nconst hostRef=getHostRef(ref);const elm=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad?hostRef.$hostElement$:ref;const oldVal=hostRef.$instanceValues$.get(propName);const flags=hostRef.$flags$;const instance=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad?hostRef.$lazyInstance$:elm;newVal=parsePropertyValue(newVal,cmpMeta.$members$[propName][0]);// explicitly check for NaN on both sides, as `NaN === NaN` is always false\nconst areBothNaN=Number.isNaN(oldVal)&&Number.isNaN(newVal);const didValueChange=newVal!==oldVal&&!areBothNaN;if((!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad||!(flags&8/* HOST_FLAGS.isConstructingInstance */)||oldVal===undefined)&&didValueChange){// gadzooks! the property's value has changed!!\n// set our new value!\nhostRef.$instanceValues$.set(propName,newVal);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){if(hostRef.$flags$&1024/* HOST_FLAGS.devOnRender */){consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,'\\nElement',elm,'\\nNew value',newVal,'\\nOld value',oldVal);}else if(hostRef.$flags$&2048/* HOST_FLAGS.devOnDidLoad */){consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`,'\\nElement',elm,'\\nNew value',newVal,'\\nOld value',oldVal);}}if(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad||instance){// get an array of method names of watch functions to call\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback&&cmpMeta.$watchers$&&flags&128/* HOST_FLAGS.isWatchReady */){const watchMethods=cmpMeta.$watchers$[propName];if(watchMethods){// this instance is watching for when this property changed\nwatchMethods.map(watchMethodName=>{try{// fire off each of the watch methods that are watching this property\ninstance[watchMethodName](newVal,oldVal,propName);}catch(e){consoleError(e,elm);}});}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable&&(flags&(2/* HOST_FLAGS.hasRendered */|16/* HOST_FLAGS.isQueuedForUpdate */))===2/* HOST_FLAGS.hasRendered */){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpShouldUpdate&&instance.componentShouldUpdate){if(instance.componentShouldUpdate(newVal,oldVal,propName)===false){return;}}// looks like this value actually changed, so we've got work to do!\n// but only if we've already rendered, otherwise just chill out\n// queue that we need to do an update, but don't worry about queuing\n// up millions cuz this function ensures it only runs once\nscheduleUpdate(hostRef,false);}}}};/**\n * Attach a series of runtime constructs to a compiled Stencil component\n * constructor, including getters and setters for the `@Prop` and `@State`\n * decorators, callbacks for when attributes change, and so on.\n *\n * @param Cstr the constructor for a component that we need to process\n * @param cmpMeta metadata collected previously about the component\n * @param flags a number used to store a series of bit flags\n * @returns a reference to the same constructor passed in (but now mutated)\n */const proxyComponent=(Cstr,cmpMeta,flags)=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member&&cmpMeta.$members$){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback&&Cstr.watchers){cmpMeta.$watchers$=Cstr.watchers;}// It's better to have a const than two Object.entries()\nconst members=Object.entries(cmpMeta.$members$);const prototype=Cstr.prototype;members.map(_ref4=>{let[memberName,[memberFlags]]=_ref4;if((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.state)&&(memberFlags&31/* MEMBER_FLAGS.Prop */||(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad||flags&2/* PROXY_FLAGS.proxyState */)&&memberFlags&32/* MEMBER_FLAGS.State */)){// proxyComponent - prop\nObject.defineProperty(prototype,memberName,{get(){// proxyComponent, get value\nreturn getValue(this,memberName);},set(newValue){// only during dev time\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){const ref=getHostRef(this);if(// we are proxying the instance (not element)\n(flags&1/* PROXY_FLAGS.isElementConstructor */)===0&&// the element is not constructing\n(ref.$flags$&8/* HOST_FLAGS.isConstructingInstance */)===0&&// the member is a prop\n(memberFlags&31/* MEMBER_FLAGS.Prop */)!==0&&// the member is not mutable\n(memberFlags&1024/* MEMBER_FLAGS.Mutable */)===0){consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);}}// proxyComponent, set value\nsetValue(this,memberName,newValue,cmpMeta);},configurable:true,enumerable:true});}else if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method&&flags&1/* PROXY_FLAGS.isElementConstructor */&&memberFlags&64/* MEMBER_FLAGS.Method */){// proxyComponent - method\nObject.defineProperty(prototype,memberName,{value(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}const ref=getHostRef(this);return ref.$onInstancePromise$.then(()=>ref.$lazyInstance$[memberName](...args));}});}});if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.observeAttribute&&(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad||flags&1/* PROXY_FLAGS.isElementConstructor */)){const attrNameToPropName=new Map();prototype.attributeChangedCallback=function(attrName,_oldValue,newValue){plt.jmp(()=>{const propName=attrNameToPropName.get(attrName);//  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n//  in the case where an attribute was set inline.\n//  ```html\n//    <my-component some-attribute=\"some-value\"></my-component>\n//  ```\n//\n//  There is an edge case where a developer sets the attribute inline on a custom element and then\n//  programmatically changes it before it has been upgraded as shown below:\n//\n//  ```html\n//    <!-- this component has _not_ been upgraded yet -->\n//    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n//    <script>\n//      // grab non-upgraded component\n//      el = document.querySelector(\"#test\");\n//      el.someAttribute = \"another-value\";\n//      // upgrade component\n//      customElements.define('my-component', MyComponent);\n//    </script>\n//  ```\n//  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n//  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n//  to the value that was set inline i.e. \"some-value\" from above example. When\n//  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n//\n//  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n//  by connectedCallback as this attributeChangedCallback will not fire.\n//\n//  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n//\n//  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n//  properties here given that this goes against best practices outlined here\n//  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\nif(this.hasOwnProperty(propName)){newValue=this[propName];delete this[propName];}else if(prototype.hasOwnProperty(propName)&&typeof this[propName]==='number'&&this[propName]==newValue){// if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n// APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n// `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\nreturn;}this[propName]=newValue===null&&typeof this[propName]==='boolean'?false:newValue;});};// create an array of attributes to observe\n// and also create a map of html attribute name to js property name\nCstr.observedAttributes=members.filter(_ref5=>{let[_,m]=_ref5;return m[0]&15;}/* MEMBER_FLAGS.HasAttribute */)// filter to only keep props that should match attributes\n.map(_ref6=>{let[propName,m]=_ref6;const attrName=m[1]||propName;attrNameToPropName.set(attrName,propName);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect&&m[0]&512/* MEMBER_FLAGS.ReflectAttr */){cmpMeta.$attrsToReflect$.push([propName,attrName]);}return attrName;});}}return Cstr;};const initializeComponent=async(elm,hostRef,cmpMeta,hmrVersionId,Cstr)=>{// initializeComponent\nif((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style)&&(hostRef.$flags$&32/* HOST_FLAGS.hasInitializedComponent */)===0){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide){// we haven't initialized this element yet\nhostRef.$flags$|=32/* HOST_FLAGS.hasInitializedComponent */;// lazy loaded components\n// request the component's implementation to be\n// wired up with the host element\nCstr=loadModule(cmpMeta,hostRef,hmrVersionId);if(Cstr.then){// Await creates a micro-task avoid if possible\nconst endLoad=uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`,`[Stencil] Load module for <${cmpMeta.$tagName$}>`);Cstr=await Cstr;endLoad();}if((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug)&&!Cstr){throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member&&!Cstr.isProxied){// we've never proxied this Constructor before\n// let's add the getters/setters to its prototype before\n// the first time we create an instance of the implementation\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback){cmpMeta.$watchers$=Cstr.watchers;}proxyComponent(Cstr,cmpMeta,2/* PROXY_FLAGS.proxyState */);Cstr.isProxied=true;}const endNewInstance=createTime('createInstance',cmpMeta.$tagName$);// ok, time to construct the instance\n// but let's keep track of when we start and stop\n// so that the getters/setters don't incorrectly step on data\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member){hostRef.$flags$|=8/* HOST_FLAGS.isConstructingInstance */;}// construct the lazy-loaded component implementation\n// passing the hostRef is very important during\n// construction in order to directly wire together the\n// host element and the lazy-loaded instance\ntry{new Cstr(hostRef);}catch(e){consoleError(e);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member){hostRef.$flags$&=~8/* HOST_FLAGS.isConstructingInstance */;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback){hostRef.$flags$|=128/* HOST_FLAGS.isWatchReady */;}endNewInstance();fireConnectedCallback(hostRef.$lazyInstance$);}else{// sync constructor component\nCstr=elm.constructor;hostRef.$flags$|=32/* HOST_FLAGS.hasInitializedComponent */;// wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n// watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n// Stencil has completed instantiating the component.\ncustomElements.whenDefined(cmpMeta.$tagName$).then(()=>hostRef.$flags$|=128/* HOST_FLAGS.isWatchReady */);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style&&Cstr.style){// this component has styles but we haven't registered them yet\nlet style=Cstr.style;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode&&typeof style!=='string'){style=style[hostRef.$modeName$=computeMode(elm)];if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide&&hostRef.$modeName$){elm.setAttribute('s-mode',hostRef.$modeName$);}}const scopeId=getScopeId(cmpMeta,hostRef.$modeName$);if(!styles.has(scopeId)){const endRegisterStyles=createTime('registerStyles',cmpMeta.$tagName$);if(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim&&cmpMeta.$flags$&8/* CMP_FLAGS.needsShadowDomShim */){style=await __webpack_require__.e(/*! import() */ \"vendors-node_modules_stencil_core_internal_client_shadow-css_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./shadow-css.js */ \"./node_modules/@stencil/core/internal/client/shadow-css.js\")).then(m=>m.scopeCss(style,scopeId,false));}registerStyle(scopeId,style,!!(cmpMeta.$flags$&1/* CMP_FLAGS.shadowDomEncapsulation */));endRegisterStyles();}}}// we've successfully created a lazy instance\nconst ancestorComponent=hostRef.$ancestorComponent$;const schedule=()=>scheduleUpdate(hostRef,true);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading&&ancestorComponent&&ancestorComponent['s-rc']){// this is the initial load and this component it has an ancestor component\n// but the ancestor component has NOT fired its will update lifecycle yet\n// so let's just cool our jets and wait for the ancestor to continue first\n// this will get fired off when the ancestor component\n// finally gets around to rendering its lazy self\n// fire off the initial update\nancestorComponent['s-rc'].push(schedule);}else{schedule();}};const fireConnectedCallback=instance=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback){safeCall(instance,'connectedCallback');}};const connectedCallback=elm=>{if((plt.$flags$&1/* PLATFORM_FLAGS.isTmpDisconnected */)===0){const hostRef=getHostRef(elm);const cmpMeta=hostRef.$cmpMeta$;const endConnected=createTime('connectedCallback',cmpMeta.$tagName$);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent){// only run if we have listeners being attached to a parent\naddHostEventListeners(elm,hostRef,cmpMeta.$listeners$,true);}if(!(hostRef.$flags$&1/* HOST_FLAGS.hasConnected */)){// first time this component has connected\nhostRef.$flags$|=1/* HOST_FLAGS.hasConnected */;let hostId;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide){hostId=elm.getAttribute(HYDRATE_ID);if(hostId){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&supportsShadow&&cmpMeta.$flags$&1/* CMP_FLAGS.shadowDomEncapsulation */){const scopeId=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode?addStyle(elm.shadowRoot,cmpMeta,elm.getAttribute('s-mode')):addStyle(elm.shadowRoot,cmpMeta);elm.classList.remove(scopeId+'-h',scopeId+'-s');}initializeClientHydrate(elm,cmpMeta.$tagName$,hostId,hostRef);}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation&&!hostId){// initUpdate\n// if the slot polyfill is required we'll need to put some nodes\n// in here to act as original content anchors as we move nodes around\n// host element has been connected to the DOM\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide||(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom)&&cmpMeta.$flags$&(4/* CMP_FLAGS.hasSlotRelocation */|8/* CMP_FLAGS.needsShadowDomShim */)){setContentReference(elm);}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading){// find the first ancestor component (if there is one) and register\n// this component as one of the actively loading child components for its ancestor\nlet ancestorComponent=elm;while(ancestorComponent=ancestorComponent.parentNode||ancestorComponent.host){// climb up the ancestors looking for the first\n// component that hasn't finished its lifecycle update yet\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide&&ancestorComponent.nodeType===1/* NODE_TYPE.ElementNode */&&ancestorComponent.hasAttribute('s-id')&&ancestorComponent['s-p']||ancestorComponent['s-p']){// we found this components first ancestor component\n// keep a reference to this component's ancestor component\nattachToAncestor(hostRef,hostRef.$ancestorComponent$=ancestorComponent);break;}}}// Lazy properties\n// https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop&&!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide&&cmpMeta.$members$){Object.entries(cmpMeta.$members$).map(_ref7=>{let[memberName,[memberFlags]]=_ref7;if(memberFlags&31/* MEMBER_FLAGS.Prop */&&elm.hasOwnProperty(memberName)){const value=elm[memberName];delete elm[memberName];elm[memberName]=value;}});}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.initializeNextTick){// connectedCallback, taskQueue, initialLoad\n// angular sets attribute AFTER connectCallback\n// https://github.com/angular/angular/issues/18909\n// https://github.com/angular/angular/issues/19940\nnextTick(()=>initializeComponent(elm,hostRef,cmpMeta));}else{initializeComponent(elm,hostRef,cmpMeta);}}else{// not the first time this has connected\n// reattach any event listeners to the host\n// since they would have been removed when disconnected\naddHostEventListeners(elm,hostRef,cmpMeta.$listeners$,false);// fire off connectedCallback() on component instance\nfireConnectedCallback(hostRef.$lazyInstance$);}endConnected();}};const setContentReference=elm=>{// only required when we're NOT using native shadow dom (slot)\n// or this browser doesn't support native shadow dom\n// and this host element was NOT created with SSR\n// let's pick out the inner content for slot projection\n// create a node to represent where the original\n// content was first placed, which is useful later on\nconst contentRefElm=elm['s-cr']=doc.createComment(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug?`content-ref (host=${elm.localName})`:'');contentRefElm['s-cn']=true;elm.insertBefore(contentRefElm,elm.firstChild);};const disconnectedCallback=elm=>{if((plt.$flags$&1/* PLATFORM_FLAGS.isTmpDisconnected */)===0){const hostRef=getHostRef(elm);const instance=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad?hostRef.$lazyInstance$:elm;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener){if(hostRef.$rmListeners$){hostRef.$rmListeners$.map(rmListener=>rmListener());hostRef.$rmListeners$=undefined;}}// clear CSS var-shim tracking\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim&&plt.$cssShim$){plt.$cssShim$.removeHost(elm);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback){safeCall(instance,'disconnectedCallback');}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUnload){safeCall(instance,'componentDidUnload');}}};const defineCustomElement=(Cstr,compactMeta)=>{customElements.define(compactMeta[1],proxyCustomElement(Cstr,compactMeta));};const proxyCustomElement=(Cstr,compactMeta)=>{const cmpMeta={$flags$:compactMeta[0],$tagName$:compactMeta[1]};if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member){cmpMeta.$members$=compactMeta[2];}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener){cmpMeta.$listeners$=compactMeta[3];}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback){cmpMeta.$watchers$=Cstr.$watchers$;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect){cmpMeta.$attrsToReflect$=[];}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&!supportsShadow&&cmpMeta.$flags$&1/* CMP_FLAGS.shadowDomEncapsulation */){cmpMeta.$flags$|=8/* CMP_FLAGS.needsShadowDomShim */;}const originalConnectedCallback=Cstr.prototype.connectedCallback;const originalDisconnectedCallback=Cstr.prototype.disconnectedCallback;Object.assign(Cstr.prototype,{__registerHost(){registerHost(this,cmpMeta);},connectedCallback(){connectedCallback(this);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback&&originalConnectedCallback){originalConnectedCallback.call(this);}},disconnectedCallback(){disconnectedCallback(this);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback&&originalDisconnectedCallback){originalDisconnectedCallback.call(this);}},__attachShadow(){if(supportsShadow){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDelegatesFocus){this.attachShadow({mode:'open',delegatesFocus:!!(cmpMeta.$flags$&16/* CMP_FLAGS.shadowDelegatesFocus */)});}else{this.attachShadow({mode:'open'});}}else{this.shadowRoot=this;}}});Cstr.is=cmpMeta.$tagName$;return proxyComponent(Cstr,cmpMeta,1/* PROXY_FLAGS.isElementConstructor */|2/* PROXY_FLAGS.proxyState */);};const forceModeUpdate=elm=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode&&!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad){const mode=computeMode(elm);const hostRef=getHostRef(elm);if(hostRef.$modeName$!==mode){const cmpMeta=hostRef.$cmpMeta$;const oldScopeId=elm['s-sc'];const scopeId=getScopeId(cmpMeta,mode);const style=elm.constructor.style[mode];const flags=cmpMeta.$flags$;if(style){if(!styles.has(scopeId)){registerStyle(scopeId,style,!!(flags&1/* CMP_FLAGS.shadowDomEncapsulation */));}hostRef.$modeName$=mode;elm.classList.remove(oldScopeId+'-h',oldScopeId+'-s');attachStyles(hostRef);forceUpdate(elm);}}}};const patchCloneNode=HostElementPrototype=>{const orgCloneNode=HostElementPrototype.cloneNode;HostElementPrototype.cloneNode=function(deep){const srcNode=this;const isShadowDom=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom?srcNode.shadowRoot&&supportsShadow:false;const clonedNode=orgCloneNode.call(srcNode,isShadowDom?deep:false);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot&&!isShadowDom&&deep){let i=0;let slotted,nonStencilNode;const stencilPrivates=['s-id','s-cr','s-lr','s-rc','s-sc','s-p','s-cn','s-sr','s-sn','s-hn','s-ol','s-nr','s-si'];for(;i<srcNode.childNodes.length;i++){slotted=srcNode.childNodes[i]['s-nr'];nonStencilNode=stencilPrivates.every(privateField=>!srcNode.childNodes[i][privateField]);if(slotted){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix&&clonedNode.__appendChild){clonedNode.__appendChild(slotted.cloneNode(true));}else{clonedNode.appendChild(slotted.cloneNode(true));}}if(nonStencilNode){clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));}}}return clonedNode;};};const patchSlotAppendChild=HostElementPrototype=>{HostElementPrototype.__appendChild=HostElementPrototype.appendChild;HostElementPrototype.appendChild=function(newChild){const slotName=newChild['s-sn']=getSlotName(newChild);const slotNode=getHostSlotNode(this.childNodes,slotName);if(slotNode){const slotChildNodes=getHostSlotChildNodes(slotNode,slotName);const appendAfter=slotChildNodes[slotChildNodes.length-1];return appendAfter.parentNode.insertBefore(newChild,appendAfter.nextSibling);}return this.__appendChild(newChild);};};/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */const patchTextContent=(hostElementPrototype,cmpMeta)=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped&&cmpMeta.$flags$&2/* CMP_FLAGS.scopedCssEncapsulation */){const descriptor=Object.getOwnPropertyDescriptor(Node.prototype,'textContent');Object.defineProperty(hostElementPrototype,'__textContent',descriptor);Object.defineProperty(hostElementPrototype,'textContent',{get(){var _a;// get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n// the empty string\nconst slotNode=getHostSlotNode(this.childNodes,'');// when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n// nodes were reordered during the vdom render. first try to get the text content from the sibling.\nif(((_a=slotNode===null||slotNode===void 0?void 0:slotNode.nextSibling)===null||_a===void 0?void 0:_a.nodeType)===3/* NODE_TYPES.TEXT_NODE */){return slotNode.nextSibling.textContent;}else if(slotNode){return slotNode.textContent;}else{// fallback to the original implementation\nreturn this.__textContent;}},set(value){var _a;// get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n// the empty string\nconst slotNode=getHostSlotNode(this.childNodes,'');// when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n// depending on how nodes were reordered during the vdom render. first try to set the text content on the\n// sibling.\nif(((_a=slotNode===null||slotNode===void 0?void 0:slotNode.nextSibling)===null||_a===void 0?void 0:_a.nodeType)===3/* NODE_TYPES.TEXT_NODE */){slotNode.nextSibling.textContent=value;}else if(slotNode){slotNode.textContent=value;}else{// we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n// loaded, we could have missed it. check for a content reference element on the scoped component and insert\n// it there\nthis.__textContent=value;const contentRefElm=this['s-cr'];if(contentRefElm){this.insertBefore(contentRefElm,this.firstChild);}}}});}};const patchChildSlotNodes=(elm,cmpMeta)=>{class FakeNodeList extends Array{item(n){return this[n];}}if(cmpMeta.$flags$&8/* CMP_FLAGS.needsShadowDomShim */){const childNodesFn=elm.__lookupGetter__('childNodes');Object.defineProperty(elm,'children',{get(){return this.childNodes.map(n=>n.nodeType===1);}});Object.defineProperty(elm,'childElementCount',{get(){return elm.children.length;}});Object.defineProperty(elm,'childNodes',{get(){const childNodes=childNodesFn.call(this);if((plt.$flags$&1/* PLATFORM_FLAGS.isTmpDisconnected */)===0&&getHostRef(this).$flags$&2/* HOST_FLAGS.hasRendered */){const result=new FakeNodeList();for(let i=0;i<childNodes.length;i++){const slot=childNodes[i]['s-nr'];if(slot){result.push(slot);}}return result;}return FakeNodeList.from(childNodes);}});}};const getSlotName=node=>node['s-sn']||node.nodeType===1&&node.getAttribute('slot')||'';/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */const getHostSlotNode=(childNodes,slotName)=>{let i=0;let childNode;for(;i<childNodes.length;i++){childNode=childNodes[i];if(childNode['s-sr']&&childNode['s-sn']===slotName){return childNode;}childNode=getHostSlotNode(childNode.childNodes,slotName);if(childNode){return childNode;}}return null;};const getHostSlotChildNodes=(n,slotName)=>{const childNodes=[n];while((n=n.nextSibling)&&n['s-sn']===slotName){childNodes.push(n);}return childNodes;};const hmrStart=(elm,cmpMeta,hmrVersionId)=>{// ¯\\_(ツ)_/¯\nconst hostRef=getHostRef(elm);// reset state flags to only have been connected\nhostRef.$flags$=1/* HOST_FLAGS.hasConnected */;// TODO\n// detatch any event listeners that may have been added\n// because we're not passing an exact event name it'll\n// remove all of this element's event, which is good\n// create a callback for when this component finishes hmr\nelm['s-hmr-load']=()=>{// finished hmr for this element\ndelete elm['s-hmr-load'];};// re-initialize the component\ninitializeComponent(elm,hostRef,cmpMeta,hmrVersionId);};const bootstrapLazy=function(lazyBundles){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile&&performance.mark){performance.mark('st:app:start');}installDevTools();const endBootstrap=createTime('bootstrapLazy');const cmpTags=[];const exclude=options.exclude||[];const customElements=win.customElements;const head=doc.head;const metaCharset=/*@__PURE__*/head.querySelector('meta[charset]');const visibilityStyle=/*@__PURE__*/doc.createElement('style');const deferredConnectedCallbacks=[];const styles=/*@__PURE__*/doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);let appLoadFallback;let isBootstrapping=true;let i=0;Object.assign(plt,options);plt.$resourcesUrl$=new URL(options.resourcesUrl||'./',doc.baseURI).href;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue){if(options.syncQueue){plt.$flags$|=4/* PLATFORM_FLAGS.queueSync */;}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide){// If the app is already hydrated there is not point to disable the\n// async queue. This will improve the first input delay\nplt.$flags$|=2/* PLATFORM_FLAGS.appLoaded */;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom){for(;i<styles.length;i++){registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID),convertScopedToShadow(styles[i].innerHTML),true);}}lazyBundles.map(lazyBundle=>{lazyBundle[1].map(compactMeta=>{const cmpMeta={$flags$:compactMeta[0],$tagName$:compactMeta[1],$members$:compactMeta[2],$listeners$:compactMeta[3]};if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member){cmpMeta.$members$=compactMeta[2];}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener){cmpMeta.$listeners$=compactMeta[3];}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect){cmpMeta.$attrsToReflect$=[];}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback){cmpMeta.$watchers$={};}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&!supportsShadow&&cmpMeta.$flags$&1/* CMP_FLAGS.shadowDomEncapsulation */){cmpMeta.$flags$|=8/* CMP_FLAGS.needsShadowDomShim */;}const tagName=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.transformTagName&&options.transformTagName?options.transformTagName(cmpMeta.$tagName$):cmpMeta.$tagName$;const HostElement=class extends HTMLElement{// StencilLazyHost\nconstructor(self){// @ts-ignore\nsuper(self);self=this;registerHost(self,cmpMeta);if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom&&cmpMeta.$flags$&1/* CMP_FLAGS.shadowDomEncapsulation */){// this component is using shadow dom\n// and this browser supports shadow dom\n// add the read-only property \"shadowRoot\" to the host element\n// adding the shadow root build conditionals to minimize runtime\nif(supportsShadow){if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDelegatesFocus){self.attachShadow({mode:'open',delegatesFocus:!!(cmpMeta.$flags$&16/* CMP_FLAGS.shadowDelegatesFocus */)});}else{self.attachShadow({mode:'open'});}}else if(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide&&!('shadowRoot'in self)){self.shadowRoot=self;}}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotChildNodesFix){patchChildSlotNodes(self,cmpMeta);}}connectedCallback(){if(appLoadFallback){clearTimeout(appLoadFallback);appLoadFallback=null;}if(isBootstrapping){// connectedCallback will be processed once all components have been registered\ndeferredConnectedCallbacks.push(this);}else{plt.jmp(()=>connectedCallback(this));}}disconnectedCallback(){plt.jmp(()=>disconnectedCallback(this));}componentOnReady(){return getHostRef(this).$onReadyPromise$;}};if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cloneNodeFix){patchCloneNode(HostElement.prototype);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix){patchSlotAppendChild(HostElement.prototype);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement){HostElement.prototype['s-hmr']=function(hmrVersionId){hmrStart(this,cmpMeta,hmrVersionId);};}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scopedSlotTextContentFix){patchTextContent(HostElement.prototype,cmpMeta);}cmpMeta.$lazyBundleId$=lazyBundle[0];if(!exclude.includes(tagName)&&!customElements.get(tagName)){cmpTags.push(tagName);customElements.define(tagName,proxyComponent(HostElement,cmpMeta,1/* PROXY_FLAGS.isElementConstructor */));}});});if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.invisiblePrehydration&&(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass||_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute)){visibilityStyle.innerHTML=cmpTags+HYDRATED_CSS;visibilityStyle.setAttribute('data-styles','');head.insertBefore(visibilityStyle,metaCharset?metaCharset.nextSibling:head.firstChild);}// Process deferred connectedCallbacks now all components have been registered\nisBootstrapping=false;if(deferredConnectedCallbacks.length){deferredConnectedCallbacks.map(host=>host.connectedCallback());}else{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile){plt.jmp(()=>appLoadFallback=setTimeout(appDidLoad,30,'timeout'));}else{plt.jmp(()=>appLoadFallback=setTimeout(appDidLoad,30));}}// Fallback appLoad event\nendBootstrap();};const getConnect=(_ref,tagName)=>{const componentOnReady=()=>{let elm=doc.querySelector(tagName);if(!elm){elm=doc.createElement(tagName);doc.body.appendChild(elm);}return typeof elm.componentOnReady==='function'?elm.componentOnReady():Promise.resolve(elm);};const create=function(){for(var _len3=arguments.length,args=new Array(_len3),_key3=0;_key3<_len3;_key3++){args[_key3]=arguments[_key3];}return componentOnReady().then(el=>el.create(...args));};return{create,componentOnReady};};const getContext=(_elm,context)=>{if(context in Context){return Context[context];}else if(context==='window'){return win;}else if(context==='document'){return doc;}else if(context==='isServer'||context==='isPrerender'){return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide?true:false;}else if(context==='isClient'){return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide?false:true;}else if(context==='resourcesUrl'||context==='publicPath'){return getAssetPath('.');}else if(context==='queue'){return{write:writeTask,read:readTask,tick:{then(cb){return nextTick(cb);}}};}return undefined;};const Fragment=(_,children)=>children;const addHostEventListeners=(elm,hostRef,listeners,attachParentListeners)=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener&&listeners){// this is called immediately within the element's constructor\n// initialize our event listeners on the host element\n// we do this now so that we can listen to events that may\n// have fired even before the instance is ready\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent){// this component may have event listeners that should be attached to the parent\nif(attachParentListeners){// this is being ran from within the connectedCallback\n// which is important so that we know the host element actually has a parent element\n// filter out the listeners to only have the ones that ARE being attached to the parent\nlisteners=listeners.filter(_ref8=>{let[flags]=_ref8;return flags&32;}/* LISTENER_FLAGS.TargetParent */);}else{// this is being ran from within the component constructor\n// everything BUT the parent element listeners should be attached at this time\n// filter out the listeners that are NOT being attached to the parent\nlisteners=listeners.filter(_ref9=>{let[flags]=_ref9;return!(flags&32/* LISTENER_FLAGS.TargetParent */);});}}listeners.map(_ref10=>{let[flags,name,method]=_ref10;const target=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTarget?getHostListenerTarget(elm,flags):elm;const handler=hostListenerProxy(hostRef,method);const opts=hostListenerOpts(flags);plt.ael(target,name,handler,opts);(hostRef.$rmListeners$=hostRef.$rmListeners$||[]).push(()=>plt.rel(target,name,handler,opts));});}};const hostListenerProxy=(hostRef,methodName)=>ev=>{try{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad){if(hostRef.$flags$&256/* HOST_FLAGS.isListenReady */){// instance is ready, let's call it's member method for this event\nhostRef.$lazyInstance$[methodName](ev);}else{(hostRef.$queuedListeners$=hostRef.$queuedListeners$||[]).push([methodName,ev]);}}else{hostRef.$hostElement$[methodName](ev);}}catch(e){consoleError(e);}};const getHostListenerTarget=(elm,flags)=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetDocument&&flags&4/* LISTENER_FLAGS.TargetDocument */)return doc;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetWindow&&flags&8/* LISTENER_FLAGS.TargetWindow */)return win;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetBody&&flags&16/* LISTENER_FLAGS.TargetBody */)return doc.body;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent&&flags&32/* LISTENER_FLAGS.TargetParent */)return elm.parentElement;return elm;};// prettier-ignore\nconst hostListenerOpts=flags=>supportsListenerOptions?{passive:(flags&1/* LISTENER_FLAGS.Passive */)!==0,capture:(flags&2/* LISTENER_FLAGS.Capture */)!==0}:(flags&2/* LISTENER_FLAGS.Capture */)!==0;const setPlatformOptions=opts=>Object.assign(plt,opts);const insertVdomAnnotations=(doc,staticComponents)=>{if(doc!=null){const docData={hostIds:0,rootLevelIds:0,staticComponents:new Set(staticComponents)};const orgLocationNodes=[];parseVNodeAnnotations(doc,doc.body,docData,orgLocationNodes);orgLocationNodes.forEach(orgLocationNode=>{if(orgLocationNode!=null){const nodeRef=orgLocationNode['s-nr'];let hostId=nodeRef['s-host-id'];let nodeId=nodeRef['s-node-id'];let childId=`${hostId}.${nodeId}`;if(hostId==null){hostId=0;docData.rootLevelIds++;nodeId=docData.rootLevelIds;childId=`${hostId}.${nodeId}`;if(nodeRef.nodeType===1/* NODE_TYPE.ElementNode */){nodeRef.setAttribute(HYDRATE_CHILD_ID,childId);}else if(nodeRef.nodeType===3/* NODE_TYPE.TextNode */){if(hostId===0){const textContent=nodeRef.nodeValue.trim();if(textContent===''){// useless whitespace node at the document root\norgLocationNode.remove();return;}}const commentBeforeTextNode=doc.createComment(childId);commentBeforeTextNode.nodeValue=`${TEXT_NODE_ID}.${childId}`;nodeRef.parentNode.insertBefore(commentBeforeTextNode,nodeRef);}}let orgLocationNodeId=`${ORG_LOCATION_ID}.${childId}`;const orgLocationParentNode=orgLocationNode.parentElement;if(orgLocationParentNode){if(orgLocationParentNode['s-en']===''){// ending with a \".\" means that the parent element\n// of this node's original location is a SHADOW dom element\n// and this node is apart of the root level light dom\norgLocationNodeId+=`.`;}else if(orgLocationParentNode['s-en']==='c'){// ending with a \".c\" means that the parent element\n// of this node's original location is a SCOPED element\n// and this node is apart of the root level light dom\norgLocationNodeId+=`.c`;}}orgLocationNode.nodeValue=orgLocationNodeId;}});}};const parseVNodeAnnotations=(doc,node,docData,orgLocationNodes)=>{if(node==null){return;}if(node['s-nr']!=null){orgLocationNodes.push(node);}if(node.nodeType===1/* NODE_TYPE.ElementNode */){node.childNodes.forEach(childNode=>{const hostRef=getHostRef(childNode);if(hostRef!=null&&!docData.staticComponents.has(childNode.nodeName.toLowerCase())){const cmpData={nodeIds:0};insertVNodeAnnotations(doc,childNode,hostRef.$vnode$,docData,cmpData);}parseVNodeAnnotations(doc,childNode,docData,orgLocationNodes);});}};const insertVNodeAnnotations=(doc,hostElm,vnode,docData,cmpData)=>{if(vnode!=null){const hostId=++docData.hostIds;hostElm.setAttribute(HYDRATE_ID,hostId);if(hostElm['s-cr']!=null){hostElm['s-cr'].nodeValue=`${CONTENT_REF_ID}.${hostId}`;}if(vnode.$children$!=null){const depth=0;vnode.$children$.forEach((vnodeChild,index)=>{insertChildVNodeAnnotations(doc,vnodeChild,cmpData,hostId,depth,index);});}if(hostElm&&vnode&&vnode.$elm$&&!hostElm.hasAttribute('c-id')){const parent=hostElm.parentElement;if(parent&&parent.childNodes){const parentChildNodes=Array.from(parent.childNodes);const comment=parentChildNodes.find(node=>node.nodeType===8/* NODE_TYPE.CommentNode */&&node['s-sr']);if(comment){const index=parentChildNodes.indexOf(hostElm)-1;vnode.$elm$.setAttribute(HYDRATE_CHILD_ID,`${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);}}}}};const insertChildVNodeAnnotations=(doc,vnodeChild,cmpData,hostId,depth,index)=>{const childElm=vnodeChild.$elm$;if(childElm==null){return;}const nodeId=cmpData.nodeIds++;const childId=`${hostId}.${nodeId}.${depth}.${index}`;childElm['s-host-id']=hostId;childElm['s-node-id']=nodeId;if(childElm.nodeType===1/* NODE_TYPE.ElementNode */){childElm.setAttribute(HYDRATE_CHILD_ID,childId);}else if(childElm.nodeType===3/* NODE_TYPE.TextNode */){const parentNode=childElm.parentNode;const nodeName=parentNode.nodeName;if(nodeName!=='STYLE'&&nodeName!=='SCRIPT'){const textNodeId=`${TEXT_NODE_ID}.${childId}`;const commentBeforeTextNode=doc.createComment(textNodeId);parentNode.insertBefore(commentBeforeTextNode,childElm);}}else if(childElm.nodeType===8/* NODE_TYPE.CommentNode */){if(childElm['s-sr']){const slotName=childElm['s-sn']||'';const slotNodeId=`${SLOT_NODE_ID}.${childId}.${slotName}`;childElm.nodeValue=slotNodeId;}}if(vnodeChild.$children$!=null){const childDepth=depth+1;vnodeChild.$children$.forEach((vnode,index)=>{insertChildVNodeAnnotations(doc,vnode,cmpData,hostId,childDepth,index);});}};const hostRefs=/*@__PURE__*/new WeakMap();const getHostRef=ref=>hostRefs.get(ref);const registerInstance=(lazyInstance,hostRef)=>hostRefs.set(hostRef.$lazyInstance$=lazyInstance,hostRef);const registerHost=(elm,cmpMeta)=>{const hostRef={$flags$:0,$hostElement$:elm,$cmpMeta$:cmpMeta,$instanceValues$:new Map()};if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev){hostRef.$renderCount$=0;}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad){hostRef.$onInstancePromise$=new Promise(r=>hostRef.$onInstanceResolve$=r);}if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading){hostRef.$onReadyPromise$=new Promise(r=>hostRef.$onReadyResolve$=r);elm['s-p']=[];elm['s-rc']=[];}addHostEventListeners(elm,hostRef,cmpMeta.$listeners$,false);return hostRefs.set(elm,hostRef);};const isMemberInElement=(elm,memberName)=>memberName in elm;const consoleError=(e,el)=>(customError||console.error)(e,el);const STENCIL_DEV_MODE=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting?['STENCIL:']// E2E testing\n:['%cstencil','color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px'];const consoleDevError=function(){for(var _len4=arguments.length,m=new Array(_len4),_key4=0;_key4<_len4;_key4++){m[_key4]=arguments[_key4];}return console.error(...STENCIL_DEV_MODE,...m);};const consoleDevWarn=function(){for(var _len5=arguments.length,m=new Array(_len5),_key5=0;_key5<_len5;_key5++){m[_key5]=arguments[_key5];}return console.warn(...STENCIL_DEV_MODE,...m);};const consoleDevInfo=function(){for(var _len6=arguments.length,m=new Array(_len6),_key6=0;_key6<_len6;_key6++){m[_key6]=arguments[_key6];}return console.info(...STENCIL_DEV_MODE,...m);};const setErrorHandler=handler=>customError=handler;const cmpModules=/*@__PURE__*/new Map();const loadModule=(cmpMeta,hostRef,hmrVersionId)=>{// loadModuleImport\nconst exportName=cmpMeta.$tagName$.replace(/-/g,'_');const bundleId=cmpMeta.$lazyBundleId$;if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev&&typeof bundleId!=='string'){consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);return undefined;}const module=!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement?cmpModules.get(bundleId):false;if(module){return module[exportName];}/*!__STENCIL_STATIC_IMPORT_SWITCH__*/return __webpack_require__(\"./node_modules/@stencil/core/internal/client lazy recursive ^\\\\.\\\\/.*\\\\.entry\\\\.js.*$ include: \\\\.entry\\\\.js$ exclude: \\\\.system\\\\.entry\\\\.js$\")(`./${bundleId}.entry.js${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement&&hmrVersionId?'?s-hmr='+hmrVersionId:''}`).then(importedModule=>{if(!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement){cmpModules.set(bundleId,importedModule);}return importedModule[exportName];},consoleError);};const styles=/*@__PURE__*/new Map();const modeResolutionChain=[];const win=typeof window!=='undefined'?window:{};const CSS=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim?win.CSS:null;const doc=win.document||{head:{}};const H=win.HTMLElement||class{};const plt={$flags$:0,$resourcesUrl$:'',jmp:h=>h(),raf:h=>requestAnimationFrame(h),ael:(el,eventName,listener,opts)=>el.addEventListener(eventName,listener,opts),rel:(el,eventName,listener,opts)=>el.removeEventListener(eventName,listener,opts),ce:(eventName,opts)=>new CustomEvent(eventName,opts)};const setPlatformHelpers=helpers=>{Object.assign(plt,helpers);};const supportsShadow=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim&&_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom?/*@__PURE__*/(()=>(doc.head.attachShadow+'').indexOf('[native')>-1)():true;const supportsListenerOptions=/*@__PURE__*/(()=>{let supportsListenerOptions=false;try{doc.addEventListener('e',null,Object.defineProperty({},'passive',{get(){supportsListenerOptions=true;}}));}catch(e){}return supportsListenerOptions;})();const promiseResolve=v=>Promise.resolve(v);const supportsConstructableStylesheets=_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS?/*@__PURE__*/(()=>{try{new CSSStyleSheet();return typeof new CSSStyleSheet().replaceSync==='function';}catch(e){}return false;})():false;const queueDomReads=[];const queueDomWrites=[];const queueDomWritesLow=[];const queueTask=(queue,write)=>cb=>{queue.push(cb);if(!queuePending){queuePending=true;if(write&&plt.$flags$&4/* PLATFORM_FLAGS.queueSync */){nextTick(flush);}else{plt.raf(flush);}}};const consume=queue=>{for(let i=0;i<queue.length;i++){try{queue[i](performance.now());}catch(e){consoleError(e);}}queue.length=0;};const consumeTimeout=(queue,timeout)=>{let i=0;let ts=0;while(i<queue.length&&(ts=performance.now())<timeout){try{queue[i++](ts);}catch(e){consoleError(e);}}if(i===queue.length){queue.length=0;}else if(i!==0){queue.splice(0,i);}};const flush=()=>{if(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue){queueCongestion++;}// always force a bunch of medium callbacks to run, but still have\n// a throttle on how many can run in a certain time\n// DOM READS!!!\nconsume(queueDomReads);// DOM WRITES!!!\nif(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue){const timeout=(plt.$flags$&6/* PLATFORM_FLAGS.queueMask */)===2/* PLATFORM_FLAGS.appLoaded */?performance.now()+14*Math.ceil(queueCongestion*(1.0/10.0)):Infinity;consumeTimeout(queueDomWrites,timeout);consumeTimeout(queueDomWritesLow,timeout);if(queueDomWrites.length>0){queueDomWritesLow.push(...queueDomWrites);queueDomWrites.length=0;}if(queuePending=queueDomReads.length+queueDomWrites.length+queueDomWritesLow.length>0){// still more to do yet, but we've run out of time\n// let's let this thing cool off and try again in the next tick\nplt.raf(flush);}else{queueCongestion=0;}}else{consume(queueDomWrites);if(queuePending=queueDomReads.length>0){// still more to do yet, but we've run out of time\n// let's let this thing cool off and try again in the next tick\nplt.raf(flush);}}};const nextTick=/*@__PURE__*/cb=>promiseResolve().then(cb);const readTask=/*@__PURE__*/queueTask(queueDomReads,false);const writeTask=/*@__PURE__*/queueTask(queueDomWrites,true);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@stencil/core/internal/client/index.js?");

/***/ }),

/***/ "./node_modules/@stencil/core/internal/app-data/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/app-data/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BUILD\": () => (/* binding */ BUILD),\n/* harmony export */   \"Env\": () => (/* binding */ Env),\n/* harmony export */   \"NAMESPACE\": () => (/* binding */ NAMESPACE)\n/* harmony export */ });\nconst BUILD={allRenderFn:false,cmpDidLoad:true,cmpDidUnload:false,cmpDidUpdate:true,cmpDidRender:true,cmpWillLoad:true,cmpWillUpdate:true,cmpWillRender:true,connectedCallback:true,disconnectedCallback:true,element:true,event:true,hasRenderFn:true,lifecycle:true,hostListener:true,hostListenerTargetWindow:true,hostListenerTargetDocument:true,hostListenerTargetBody:true,hostListenerTargetParent:false,hostListenerTarget:true,member:true,method:true,mode:true,observeAttribute:true,prop:true,propMutable:true,reflect:true,scoped:true,shadowDom:true,slot:true,cssAnnotations:true,state:true,style:true,svg:true,updatable:true,vdomAttribute:true,vdomXlink:true,vdomClass:true,vdomFunctional:true,vdomKey:true,vdomListener:true,vdomRef:true,vdomPropOrAttr:true,vdomRender:true,vdomStyle:true,vdomText:true,watchCallback:true,taskQueue:true,hotModuleReplacement:false,isDebug:false,isDev:false,isTesting:false,hydrateServerSide:false,hydrateClientSide:false,lifecycleDOMEvents:false,lazyLoad:false,profile:false,slotRelocation:true,appendChildSlotFix:false,cloneNodeFix:false,hydratedAttribute:false,hydratedClass:true,safari10:false,scriptDataOpts:false,scopedSlotTextContentFix:false,shadowDomShim:false,slotChildNodesFix:false,invisiblePrehydration:true,propBoolean:true,propNumber:true,propString:true,cssVarShim:false,constructableCSS:true,cmpShouldUpdate:true,devTools:false,dynamicImportShim:false,shadowDelegatesFocus:true,initializeNextTick:false,asyncLoading:false,asyncQueue:false,transformTagName:false,attachStyles:true};const Env={};const NAMESPACE=/* default */'app';\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@stencil/core/internal/app-data/index.js?");

/***/ })

}]);