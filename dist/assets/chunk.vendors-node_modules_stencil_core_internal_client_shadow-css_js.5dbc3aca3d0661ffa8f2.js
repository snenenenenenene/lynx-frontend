"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunk_ember_auto_import_"] = globalThis["webpackChunk_ember_auto_import_"] || []).push([["vendors-node_modules_stencil_core_internal_client_shadow-css_js"],{

/***/ "./node_modules/@stencil/core/internal/client/shadow-css.js":
/*!******************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/shadow-css.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scopeCss\": () => (/* binding */ scopeCss)\n/* harmony export */ });\n/*\n Stencil Client Platform v2.18.1 | MIT Licensed | https://stenciljs.com\n */ /**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n *\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts\n */const safeSelector=selector=>{const placeholders=[];let index=0;// Replaces attribute selectors with placeholders.\n// The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\nselector=selector.replace(/(\\[[^\\]]*\\])/g,(_,keep)=>{const replaceBy=`__ph-${index}__`;placeholders.push(keep);index++;return replaceBy;});// Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n// WS and \"+\" would otherwise be interpreted as selector separators.\nconst content=selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g,(_,pseudo,exp)=>{const replaceBy=`__ph-${index}__`;placeholders.push(exp);index++;return pseudo+replaceBy;});const ss={content,placeholders};return ss;};const restoreSafeSelector=(placeholders,content)=>{return content.replace(/__ph-(\\d+)__/g,(_,index)=>placeholders[+index]);};const _polyfillHost='-shadowcsshost';const _polyfillSlotted='-shadowcssslotted';// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext='-shadowcsscontext';const _parenSuffix=')(?:\\\\(('+'(?:\\\\([^)(]*\\\\)|[^)(]*)+?'+')\\\\))?([^,{]*)';const _cssColonHostRe=new RegExp('('+_polyfillHost+_parenSuffix,'gim');const _cssColonHostContextRe=new RegExp('('+_polyfillHostContext+_parenSuffix,'gim');const _cssColonSlottedRe=new RegExp('('+_polyfillSlotted+_parenSuffix,'gim');const _polyfillHostNoCombinator=_polyfillHost+'-no-combinator';const _polyfillHostNoCombinatorRe=/-shadowcsshost-no-combinator([^\\s]*)/;const _shadowDOMSelectorsRe=[/::shadow/g,/::content/g];const _selectorReSuffix='([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';const _polyfillHostRe=/-shadowcsshost/gim;const _colonHostRe=/:host/gim;const _colonSlottedRe=/::slotted/gim;const _colonHostContextRe=/:host-context/gim;const _commentRe=/\\/\\*\\s*[\\s\\S]*?\\*\\//g;const stripComments=input=>{return input.replace(_commentRe,'');};const _commentWithHashRe=/\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;const extractCommentsWithHash=input=>{return input.match(_commentWithHashRe)||[];};const _ruleRe=/(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;const _curlyRe=/([{}])/g;const _selectorPartsRe=/(^.*?[^\\\\])??((:+)(.*)|$)/;const OPEN_CURLY='{';const CLOSE_CURLY='}';const BLOCK_PLACEHOLDER='%BLOCK%';const processRules=(input,ruleCallback)=>{const inputWithEscapedBlocks=escapeBlocks(input);let nextBlockIndex=0;return inputWithEscapedBlocks.escapedString.replace(_ruleRe,function(){const selector=arguments.length<=2?undefined:arguments[2];let content='';let suffix=arguments.length<=4?undefined:arguments[4];let contentPrefix='';if(suffix&&suffix.startsWith('{'+BLOCK_PLACEHOLDER)){content=inputWithEscapedBlocks.blocks[nextBlockIndex++];suffix=suffix.substring(BLOCK_PLACEHOLDER.length+1);contentPrefix='{';}const cssRule={selector,content};const rule=ruleCallback(cssRule);return`${arguments.length<=1?undefined:arguments[1]}${rule.selector}${arguments.length<=3?undefined:arguments[3]}${contentPrefix}${rule.content}${suffix}`;});};const escapeBlocks=input=>{const inputParts=input.split(_curlyRe);const resultParts=[];const escapedBlocks=[];let bracketCount=0;let currentBlockParts=[];for(let partIndex=0;partIndex<inputParts.length;partIndex++){const part=inputParts[partIndex];if(part===CLOSE_CURLY){bracketCount--;}if(bracketCount>0){currentBlockParts.push(part);}else{if(currentBlockParts.length>0){escapedBlocks.push(currentBlockParts.join(''));resultParts.push(BLOCK_PLACEHOLDER);currentBlockParts=[];}resultParts.push(part);}if(part===OPEN_CURLY){bracketCount++;}}if(currentBlockParts.length>0){escapedBlocks.push(currentBlockParts.join(''));resultParts.push(BLOCK_PLACEHOLDER);}const strEscapedBlocks={escapedString:resultParts.join(''),blocks:escapedBlocks};return strEscapedBlocks;};const insertPolyfillHostInCssText=selector=>{selector=selector.replace(_colonHostContextRe,_polyfillHostContext).replace(_colonHostRe,_polyfillHost).replace(_colonSlottedRe,_polyfillSlotted);return selector;};const convertColonRule=(cssText,regExp,partReplacer)=>{// m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\nreturn cssText.replace(regExp,function(){for(var _len=arguments.length,m=new Array(_len),_key=0;_key<_len;_key++){m[_key]=arguments[_key];}if(m[2]){const parts=m[2].split(',');const r=[];for(let i=0;i<parts.length;i++){const p=parts[i].trim();if(!p)break;r.push(partReplacer(_polyfillHostNoCombinator,p,m[3]));}return r.join(',');}else{return _polyfillHostNoCombinator+m[3];}});};const colonHostPartReplacer=(host,part,suffix)=>{return host+part.replace(_polyfillHost,'')+suffix;};const convertColonHost=cssText=>{return convertColonRule(cssText,_cssColonHostRe,colonHostPartReplacer);};const colonHostContextPartReplacer=(host,part,suffix)=>{if(part.indexOf(_polyfillHost)>-1){return colonHostPartReplacer(host,part,suffix);}else{return host+part+suffix+', '+part+' '+host+suffix;}};const convertColonSlotted=(cssText,slotScopeId)=>{const slotClass='.'+slotScopeId+' > ';const selectors=[];cssText=cssText.replace(_cssColonSlottedRe,function(){for(var _len2=arguments.length,m=new Array(_len2),_key2=0;_key2<_len2;_key2++){m[_key2]=arguments[_key2];}if(m[2]){const compound=m[2].trim();const suffix=m[3];const slottedSelector=slotClass+compound+suffix;let prefixSelector='';for(let i=m[4]-1;i>=0;i--){const char=m[5][i];if(char==='}'||char===','){break;}prefixSelector=char+prefixSelector;}const orgSelector=prefixSelector+slottedSelector;const addedSelector=`${prefixSelector.trimRight()}${slottedSelector.trim()}`;if(orgSelector.trim()!==addedSelector.trim()){const updatedSelector=`${addedSelector}, ${orgSelector}`;selectors.push({orgSelector,updatedSelector});}return slottedSelector;}else{return _polyfillHostNoCombinator+m[3];}});return{selectors,cssText};};const convertColonHostContext=cssText=>{return convertColonRule(cssText,_cssColonHostContextRe,colonHostContextPartReplacer);};const convertShadowDOMSelectors=cssText=>{return _shadowDOMSelectorsRe.reduce((result,pattern)=>result.replace(pattern,' '),cssText);};const makeScopeMatcher=scopeSelector=>{const lre=/\\[/g;const rre=/\\]/g;scopeSelector=scopeSelector.replace(lre,'\\\\[').replace(rre,'\\\\]');return new RegExp('^('+scopeSelector+')'+_selectorReSuffix,'m');};const selectorNeedsScoping=(selector,scopeSelector)=>{const re=makeScopeMatcher(scopeSelector);return!re.test(selector);};const injectScopingSelector=(selector,scopingSelector)=>{return selector.replace(_selectorPartsRe,function(_){let before=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';let _colonGroup=arguments.length>2?arguments[2]:undefined;let colon=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'';let after=arguments.length>4&&arguments[4]!==undefined?arguments[4]:'';return before+scopingSelector+colon+after;});};const applySimpleSelectorScope=(selector,scopeSelector,hostSelector)=>{// In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n_polyfillHostRe.lastIndex=0;if(_polyfillHostRe.test(selector)){const replaceBy=`.${hostSelector}`;return selector.replace(_polyfillHostNoCombinatorRe,(_,selector)=>injectScopingSelector(selector,replaceBy)).replace(_polyfillHostRe,replaceBy+' ');}return scopeSelector+' '+selector;};const applyStrictSelectorScope=(selector,scopeSelector,hostSelector)=>{const isRe=/\\[is=([^\\]]*)\\]/g;scopeSelector=scopeSelector.replace(isRe,function(_){return arguments.length<=1?undefined:arguments[1];});const className='.'+scopeSelector;const _scopeSelectorPart=p=>{let scopedP=p.trim();if(!scopedP){return'';}if(p.indexOf(_polyfillHostNoCombinator)>-1){scopedP=applySimpleSelectorScope(p,scopeSelector,hostSelector);}else{// remove :host since it should be unnecessary\nconst t=p.replace(_polyfillHostRe,'');if(t.length>0){scopedP=injectScopingSelector(t,className);}}return scopedP;};const safeContent=safeSelector(selector);selector=safeContent.content;let scopedSelector='';let startIndex=0;let res;const sep=/( |>|\\+|~(?!=))\\s*/g;// If a selector appears before :host it should not be shimmed as it\n// matches on ancestor elements and not on elements in the host's shadow\n// `:host-context(div)` is transformed to\n// `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n// the `div` is not part of the component in the 2nd selectors and should not be scoped.\n// Historically `component-tag:host` was matching the component so we also want to preserve\n// this behavior to avoid breaking legacy apps (it should not match).\n// The behavior should be:\n// - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n// - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n//   `:host-context(tag)`)\nconst hasHost=selector.indexOf(_polyfillHostNoCombinator)>-1;// Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\nlet shouldScope=!hasHost;while((res=sep.exec(selector))!==null){const separator=res[1];const part=selector.slice(startIndex,res.index).trim();shouldScope=shouldScope||part.indexOf(_polyfillHostNoCombinator)>-1;const scopedPart=shouldScope?_scopeSelectorPart(part):part;scopedSelector+=`${scopedPart} ${separator} `;startIndex=sep.lastIndex;}const part=selector.substring(startIndex);shouldScope=shouldScope||part.indexOf(_polyfillHostNoCombinator)>-1;scopedSelector+=shouldScope?_scopeSelectorPart(part):part;// replace the placeholders with their original values\nreturn restoreSafeSelector(safeContent.placeholders,scopedSelector);};const scopeSelector=(selector,scopeSelectorText,hostSelector,slotSelector)=>{return selector.split(',').map(shallowPart=>{if(slotSelector&&shallowPart.indexOf('.'+slotSelector)>-1){return shallowPart.trim();}if(selectorNeedsScoping(shallowPart,scopeSelectorText)){return applyStrictSelectorScope(shallowPart,scopeSelectorText,hostSelector).trim();}else{return shallowPart.trim();}}).join(', ');};const scopeSelectors=(cssText,scopeSelectorText,hostSelector,slotSelector,commentOriginalSelector)=>{return processRules(cssText,rule=>{let selector=rule.selector;let content=rule.content;if(rule.selector[0]!=='@'){selector=scopeSelector(rule.selector,scopeSelectorText,hostSelector,slotSelector);}else if(rule.selector.startsWith('@media')||rule.selector.startsWith('@supports')||rule.selector.startsWith('@page')||rule.selector.startsWith('@document')){content=scopeSelectors(rule.content,scopeSelectorText,hostSelector,slotSelector);}const cssRule={selector:selector.replace(/\\s{2,}/g,' ').trim(),content};return cssRule;});};const scopeCssText=(cssText,scopeId,hostScopeId,slotScopeId,commentOriginalSelector)=>{cssText=insertPolyfillHostInCssText(cssText);cssText=convertColonHost(cssText);cssText=convertColonHostContext(cssText);const slotted=convertColonSlotted(cssText,slotScopeId);cssText=slotted.cssText;cssText=convertShadowDOMSelectors(cssText);if(scopeId){cssText=scopeSelectors(cssText,scopeId,hostScopeId,slotScopeId);}cssText=cssText.replace(/-shadowcsshost-no-combinator/g,`.${hostScopeId}`);cssText=cssText.replace(/>\\s*\\*\\s+([^{, ]+)/gm,' $1 ');return{cssText:cssText.trim(),slottedSelectors:slotted.selectors};};const scopeCss=(cssText,scopeId,commentOriginalSelector)=>{const hostScopeId=scopeId+'-h';const slotScopeId=scopeId+'-s';const commentsWithHash=extractCommentsWithHash(cssText);cssText=stripComments(cssText);const orgSelectors=[];if(commentOriginalSelector){const processCommentedSelector=rule=>{const placeholder=`/*!@___${orgSelectors.length}___*/`;const comment=`/*!@${rule.selector}*/`;orgSelectors.push({placeholder,comment});rule.selector=placeholder+rule.selector;return rule;};cssText=processRules(cssText,rule=>{if(rule.selector[0]!=='@'){return processCommentedSelector(rule);}else if(rule.selector.startsWith('@media')||rule.selector.startsWith('@supports')||rule.selector.startsWith('@page')||rule.selector.startsWith('@document')){rule.content=processRules(rule.content,processCommentedSelector);return rule;}return rule;});}const scoped=scopeCssText(cssText,scopeId,hostScopeId,slotScopeId);cssText=[scoped.cssText,...commentsWithHash].join('\\n');if(commentOriginalSelector){orgSelectors.forEach(_ref=>{let{placeholder,comment}=_ref;cssText=cssText.replace(placeholder,comment);});}scoped.slottedSelectors.forEach(slottedSelector=>{cssText=cssText.replace(slottedSelector.orgSelector,slottedSelector.updatedSelector);});return cssText;};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@stencil/core/internal/client/shadow-css.js?");

/***/ })

}]);